{
  "go:goroutine": {
    "prefix": "go_anon",
    "body": ["go func() {", "\t$1", "}()"],
    "description": "Create a goroutine with an anonymous function"
  },
  "go:goroutine with function": {
    "prefix": "go_callable",
    "body": ["go ${1:functionName}(${2:args})"],
    "description": "Create a goroutine with a specified function"
  },
  "go:goroutine with delay": {
    "prefix": "go_anon_with_delay",
    "body": ["go func() {", "\ttime.Sleep(${1:duration})", "\t$2", "}()"],
    "description": "Create a goroutine with a delay"
  },
  "go:goroutine with channel": {
    "prefix": "go_anon_with_channel",
    "body": ["go func() {", "\t${1:channel} <- ${2:value}", "}()"],
    "description": "Create a goroutine with a channel for communication"
  },
  "go:goroutine with select": {
    "prefix": "go_anon_with_select",
    "body": [
      "go func() {",
      "\tselect {",
      "\tcase ${1:msg} := <-${2:channel}:",
      "\t\t$3",
      "\t}",
      "}()"
    ],
    "description": "Create a goroutine with select statement for multiple channel operations"
  },
  "go:goroutine with context": {
    "prefix": "go_anon_with_for_context_done",
    "body": [
      "go func(ctx context.Context) {",
      "\tfor {",
      "\t\tselect {",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\tdefault:",
      "\t\t\t$1",
      "\t\t}",
      "\t}",
      "}(ctx)"
    ],
    "description": "Create a goroutine with context for cancellation"
  },
  "go:goroutine with defer": {
    "prefix": "go_anon_with_defer",
    "body": [
      "go func() {",
      "\tdefer func() {",
      "\t\t$1",
      "\t}()",
      "\t$2",
      "}()"
    ],
    "description": "Create a goroutine with defer statement"
  },
  "go:goroutine with waitgroup": {
    "prefix": "go_anon_with_waitgroup",
    "body": [
      "var wg sync.WaitGroup",
      "wg.Add(1)",
      "go func() {",
      "\tdefer wg.Done()",
      "\t$1",
      "}()",
      "wg.Wait()"
    ],
    "description": "Create a goroutine with sync.WaitGroup"
  },
  "go:goroutine with context and cancel": {
    "prefix": "go_anon_with_context_and_cancel",
    "body": [
      "ctx, cancel := context.WithCancel(context.Background())",
      "defer cancel()",
      "go func(ctx context.Context) {",
      "\tfor {",
      "\t\tselect {",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\tdefault:",
      "\t\t\t$1",
      "\t\t}",
      "\t}",
      "}(ctx)"
    ],
    "description": "Create a goroutine with context and cancellation"
  },
  "go:goroutine with timeout": {
    "prefix": "go_anon_with_timeout",
    "body": [
      "go func() {",
      "\tselect {",
      "\tcase <-time.After(${1:duration}):",
      "\t\t$2",
      "\t}",
      "}()"
    ],
    "description": "Create a goroutine with timeout using time.After"
  },
  "go:goroutine receive from channel (many-to-one)": {
    "prefix": "go_anon_receive_chan_many_to_one",
    "body": [
      "go func() {",
      "\tfor {",
      "\t\tselect {",
      "\t\tcase data := <-ch:",
      "\t\t\t// Lakukan sesuatu dengan data",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\t}",
      "\t}",
      "}()"
    ],
    "description": "Create a goroutine to receive from a channel."
  },
  "go:goroutine for select goroutine": {
    "prefix": "go_anon_for_select_goroutine",
    "body": [
      "go func() {",
      "\tfor {",
      "\t\tselect {",
      "\t\tcase data := <-ch:",
      "\t\t\t// Lakukan sesuatu dengan data",
      "\t\tcase <-time.After(interval):",
      "\t\t\t// Lakukan sesuatu secara berkala",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\t}",
      "\t}",
      "}()"
    ],
    "description": "Create a goroutine with for loop and select statement."
  },
  "go:goroutine send to channel (one-to-many)": {
    "prefix": "go_anon_send_chan_one_to_many",
    "body": [
      "go func() {",
      "\tfor {",
      "\t\t// Lakukan sesuatu untuk menghasilkan data",
      "\t\tdata := generateData()",
      "\t\tselect {",
      "\t\tcase ch <- data:",
      "\t\t\t// Data berhasil dikirim",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\t}",
      "\t}",
      "}()"
    ],
    "description": "Create a goroutine to send to a channel."
  },
  "go:goroutine read from channel (many-to-many)": {
    "prefix": "go_anon_read_channel",
    "body": [
      "go func() {",
      "\tfor {",
      "\t\tselect {",
      "\t\tcase data := <-ch:",
      "\t\t\t// Lakukan sesuatu dengan data",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\t}",
      "\t}",
      "}()"
    ],
    "description": "Create a goroutine to read from a channel."
  },
  "go:goroutine for read channel": {
    "prefix": "go_anon_for_read_channel",
    "body": [
      "go func(ch <-chan ${1:Type}) {",
      "\tfor ${2:data} := range ch {",
      "\t\t${3:// Process each data element}",
      "\t}",
      "}(${4:ch})"
    ],
    "description": "goroutine function that receives data from a buffered channel"
  },
  "func:go:with timeout": {
    "prefix": "func_go_with_timeout",
    "body": [
      "func ${1:functionName}(ctx context.Context, ${2:params}) ${3:returnType} {",
      "\tch := make(chan ${4:returnType}, 1)",
      "\tgo func() {",
      "\t\tselect {",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\tcase ch <- ${5:functionCall}(${6:params}):",
      "\t\t}",
      "\t}()",
      "\tselect {",
      "\tcase <-ctx.Done():",
      "\t\t${7:// handle timeout}",
      "\t\treturn ${8:defaultValue}",
      "\tcase result := <-ch:",
      "\t\treturn result",
      "\t}",
      "}"
    ],
    "description": "Create a function with timeout using goroutine and context"
  },
  "func:go:with retry": {
    "prefix": "func_go_with_retry",
    "body": [
      "func ${1:functionName}(ctx context.Context, ${2:params}) (${3:returnType}, error) {",
      "\tvar err error",
      "\tattempt := 0",
      "\tfor {",
      "\t\tattempt++",
      "\t\tresult, e := ${4:functionCall}(${5:params})",
      "\t\tif e == nil {",
      "\t\t\treturn result, nil",
      "\t\t}",
      "\t\terr = e",
      "\t\t${6:// Optionally check for specific errors or retry conditions}",
      "\t\tif attempt >= ${7:maxAttempts} {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tselect {",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn ${8:defaultValue}, ctx.Err()",
      "\t\tcase <-time.After(${9:retryInterval}):",
      "\t\t\tcontinue",
      "\t\t}",
      "\t}",
      "\treturn ${10:defaultValue}, err",
      "}"
    ],
    "description": "Create a function with retry using goroutine and context"
  },
  "func:go:with cancellation": {
    "prefix": "func_go_with_cancellation",
    "body": [
      "func ${1:functionName}(ctx context.Context, ${2:params}) (${3:returnType}, error) {",
      "\tch := make(chan struct{})",
      "\tgo func() {",
      "\t\tdefer close(ch)",
      "\t\tselect {",
      "\t\tcase <-ctx.Done():",
      "\t\t\treturn",
      "\t\tdefault:",
      "\t\t}",
      "\t\t${4:functionCall}(${5:params})",
      "\t}()",
      "\tselect {",
      "\tcase <-ctx.Done():",
      "\t\treturn ${6:defaultValue}, ctx.Err()",
      "\tcase <-ch:",
      "\t\treturn ${7:returnValue}, nil",
      "\t}",
      "}"
    ],
    "description": "Create a function with cancellation using goroutine and context"
  },
  "func:go:with timeout (time.after)": {
    "prefix": "func_go_with_timeout_time_after",
    "body": [
      "func ${1:functionName}(timeout time.Duration, ${2:params}) (${3:returnType}, error) {",
      "\tresultCh := make(chan (${3:returnType}, error))",
      "\tgo func() {",
      "\t\tdefer close(resultCh)",
      "\t\t${4:result}, ${5:err} := ${6:functionCall}(${7:params})",
      "\t\tresultCh <- (${4:result}, ${5:err})",
      "\t}()",
      "\tselect {",
      "\tcase <-time.After(timeout):",
      "\t\treturn ${8:defaultValue}, fmt.Errorf(\"timeout after %s\", timeout)",
      "\tcase result := <-resultCh:",
      "\t\treturn result",
      "\t}",
      "}"
    ],
    "description": "Create a function with timeout using goroutine and time.After"
  },
  "func:go:with retry and backoff": {
    "prefix": "func_go_with_retry_and_backoff",
    "body": [
      "func ${1:functionName}(maxAttempts int, initialDelay, maxDelay time.Duration, ${2:params}) (${3:returnType}, error) {",
      "\tdelay := initialDelay",
      "\tfor attempt := 0; ; attempt++ {",
      "\t\t${4:result}, ${5:err} := ${6:functionCall}(${7:params})",
      "\t\tif ${8:err} == nil {",
      "\t\t\treturn ${4:result}, nil",
      "\t\t}",
      "\t\tif attempt >= maxAttempts - 1 {",
      "\t\t\tbreak",
      "\t\t}",
      "\t\tdelay = time.Duration(float64(delay) * ${9:1.5})",
      "\t\tif delay > maxDelay {",
      "\t\t\tdelay = maxDelay",
      "\t\t}",
      "\t\ttime.Sleep(delay)",
      "\t}",
      "\treturn ${10:defaultValue}, ${11:err}",
      "}"
    ],
    "description": "Create a function with retry and backoff using goroutine and time.Sleep"
  },
  "func:go:with context and cancellation": {
    "prefix": "func_go_with_context_and_cancellation",
    "body": [
      "func ${1:functionName}(ctx context.Context, ${2:params}) (${3:returnType}, error) {",
      "\tctx, cancel := context.WithCancel(ctx)",
      "\tdefer cancel()",
      "\tresultCh := make(chan (${3:returnType}, error))",
      "\tgo func() {",
      "\t\tdefer close(resultCh)",
      "\t\t${4:result}, ${5:err} := ${6:functionCall}(${7:params})",
      "\t\tresultCh <- (${4:result}, ${5:err})",
      "\t}()",
      "\tselect {",
      "\tcase <-ctx.Done():",
      "\t\treturn ${8:defaultValue}, ctx.Err()",
      "\tcase result := <-resultCh:",
      "\t\treturn result",
      "\t}",
      "}"
    ],
    "description": "Create a function with context and cancellation using goroutine"
  },
  "func:go:with timeout and retry": {
    "prefix": "func_go_with_timeout_and_retry",
    "body": [
      "func ${1:functionName}(timeout time.Duration, maxAttempts int, ${2:params}) (${3:returnType}, error) {",
      "\tresultCh := make(chan (${3:returnType}, error))",
      "\tgo func() {",
      "\t\tdefer close(resultCh)",
      "\t\tdelay := time.Millisecond * 100",
      "\t\tfor attempt := 0; attempt < maxAttempts; attempt++ {",
      "\t\t\t${4:result}, ${5:err} := ${6:functionCall}(${7:params})",
      "\t\t\tif ${8:err} == nil {",
      "\t\t\t\tresultCh <- (${4:result}, ${5:err})",
      "\t\t\t\treturn",
      "\t\t\t}",
      "\t\t\ttime.Sleep(delay)",
      "\t\t\tdelay *= 2",
      "\t\t}",
      "\t}()",
      "\tselect {",
      "\tcase <-time.After(timeout):",
      "\t\treturn ${9:defaultValue}, fmt.Errorf(\"timeout after %s\", timeout)",
      "\tcase result := <-resultCh:",
      "\t\treturn result",
      "\t}",
      "}"
    ],
    "description": "Create a function with timeout and retry using goroutine and time.After"
  },
  "func:go:return-channel": {
    "prefix": "func_go_return_channel",
    "body": [
      "func ${1:goroutineFuncName}() <-chan ${2:Type} {",
      "\tout := make(chan ${2:Type})",
      "\tgo func() {",
      "\t\tdefer close(out)",
      "\t\t${3:// Your goroutine logic}",
      "\t}()",
      "\treturn out",
      "}"
    ],
    "description": "Write a goroutine function that returns a channel"
  },
  "func:go:output-buffered-channel": {
    "prefix": "func_go_return_buffered_channel",
    "body": [
      "func ${1:goroutineFuncName}() chan<- ${2:Type} {",
      "\tout := make(chan ${2:Type}, ${3:BufferSize})",
      "\tgo func() {",
      "\t\tdefer close(out)",
      "\t\t${4:// Your goroutine logic}",
      "\t}()",
      "\treturn out",
      "}"
    ],
    "description": "Write a goroutine function that returns a buffered channel"
  },
  "func:template:go:many-to-many goroutine pattern": {
    "prefix": "func_template_go_many_to_many_goroutine_pattern",
    "body": [
      "func main() {",
      "\t// Many-to-Many Goroutine Pattern",
      "\tvar wg sync.WaitGroup",
      "\tch := make(chan int)",
      "\tconst numWorkers = 5",
      "",
      "\tfor i := 0; i < numWorkers; i++ {",
      "\t\twg.Add(1)",
      "\t\tgo func(id int) {",
      "\t\t\tdefer wg.Done()",
      "\t\t\tfor msg := range ch {",
      "\t\t\t\t// Process msg",
      "\t\t\t\tfmt.Printf(\"Worker %d processed message: %d\\n\", id, msg)",
      "\t\t\t}",
      "\t\t}(i)",
      "\t}",
      "",
      "\t// Send messages",
      "\tfor i := 0; i < 10; i++ {",
      "\t\tch <- i",
      "\t}",
      "\tclose(ch)",
      "",
      "\t// Wait for all workers to finish",
      "\twg.Wait()",
      "}"
    ],
    "description": "Many-to-Many Goroutine Pattern in Go"
  },
  "func:template:go:one-to-many goroutine pattern": {
    "prefix": "func_template_go_one_to_many_goroutine_pattern",
    "body": [
      "func main() {",
      "\t// One-to-Many Goroutine Pattern",
      "\tvar wg sync.WaitGroup",
      "\tch := make(chan int)",
      "",
      "\t// Receiver",
      "\tgo func() {",
      "\t\tdefer wg.Done()",
      "\t\tfor msg := range ch {",
      "\t\t\t// Process msg",
      "\t\t\tfmt.Printf(\"Received message: %d\\n\", msg)",
      "\t\t}",
      "\t}()",
      "\twg.Add(1)",
      "",
      "\t// Send messages",
      "\tfor i := 0; i < 10; i++ {",
      "\t\tch <- i",
      "\t}",
      "\tclose(ch)",
      "",
      "\t// Wait for the receiver to finish",
      "\twg.Wait()",
      "}"
    ],
    "description": "One-to-Many Goroutine Pattern in Go"
  },
  "func:template:go:many-to-one goroutine pattern": {
    "prefix": "func_template_go_many_to_one_goroutine_pattern",
    "body": [
      "package main",
      "",
      "import (",
      "\t\"fmt\"",
      "\t\"sync\"",
      ")",
      "",
      "func main() {",
      "\t// Many-to-One Goroutine Pattern",
      "\tvar wg sync.WaitGroup",
      "\tch := make(chan int)",
      "",
      "\t// Sender",
      "\tfor i := 0; i < 5; i++ {",
      "\t\twg.Add(1)",
      "\t\tgo func(id int) {",
      "\t\t\tdefer wg.Done()",
      "\t\t\tch <- id",
      "\t\t}(i)",
      "\t}",
      "",
      "\t// Receiver",
      "\tgo func() {",
      "\t\tdefer wg.Done()",
      "\t\tfor msg := range ch {",
      "\t\t\t// Process msg",
      "\t\t\tfmt.Printf(\"Received message: %d\\n\", msg)",
      "\t\t}",
      "\t}()",
      "\twg.Add(1)",
      "",
      "\t// Wait for all senders and receiver to finish",
      "\twg.Wait()",
      "\tclose(ch)",
      "}"
    ],
    "description": "Many-to-One Goroutine Pattern in Go"
  },
  "func:template:go:one-to-one goroutine pattern": {
    "prefix": "func_template_go_one_to_one_goroutine_pattern",
    "body": [
      "package main",
      "",
      "import (",
      "\t\"fmt\"",
      "\t\"sync\"",
      ")",
      "",
      "func main() {",
      "\t// One-to-One Goroutine Pattern",
      "\tvar wg sync.WaitGroup",
      "\tch := make(chan int)",
      "",
      "\t// Sender",
      "\twg.Add(1)",
      "\tgo func() {",
      "\t\tdefer wg.Done()",
      "\t\tch <- 42",
      "\t}()",
      "",
      "\t// Receiver",
      "\twg.Add(1)",
      "\tgo func() {",
      "\t\tdefer wg.Done()",
      "\t\tmsg := <-ch",
      "\t\tfmt.Printf(\"Received message: %d\\n\", msg)",
      "\t}()",
      "",
      "\t// Wait for sender and receiver to finish",
      "\twg.Wait()",
      "\tclose(ch)",
      "}"
    ],
    "description": "One-to-One Goroutine Pattern in Go"
  },
  "func:template:go:pipline goroutine pattern": {
    "prefix": "func_template_go_pipeline_goroutine_pattern",
    "body": [
      "package main",
      "",
      "import (",
      "\t\"fmt\"",
      ")",
      "",
      "func main() {",
      "\t// Pipeline Goroutine Pattern",
      "\tjobs := make(chan int)",
      "\tresults := make(chan int)",
      "",
      "\t// Stage 1: Producer",
      "\tgo func() {",
      "\t\tfor j := 1; j <= 5; j++ {",
      "\t\t\tjobs <- j",
      "\t\t}",
      "\t\tclose(jobs)",
      "\t}()",
      "",
      "\t// Stage 2: Worker",
      "\tgo func() {",
      "\t\tfor job := range jobs {",
      "\t\t\tresults <- job * 2",
      "\t\t}",
      "\t\tclose(results)",
      "\t}()",
      "",
      "\t// Stage 3: Consumer",
      "\tfor result := range results {",
      "\t\tfmt.Println(result)",
      "\t}",
      "}"
    ],
    "description": "Pipeline Goroutine Pattern in Go"
  },
  "func:template:go:select goroutine pattern": {
    "prefix": "func_template_go_select_goroutine_pattern",
    "body": [
      "package main",
      "",
      "import (",
      "\t\"fmt\"",
      "\t\"time\"",
      ")",
      "",
      "func main() {",
      "\t// Select Goroutine Pattern",
      "\tch1 := make(chan string)",
      "\tch2 := make(chan string)",
      "",
      "\t// Goroutine 1",
      "\tgo func() {",
      "\t\ttime.Sleep(2 * time.Second)",
      "\t\tch1 <- \"message from ch1\"",
      "\t}()",
      "",
      "\t// Goroutine 2",
      "\tgo func() {",
      "\t\ttime.Sleep(1 * time.Second)",
      "\t\tch2 <- \"message from ch2\"",
      "\t}()",
      "",
      "\t// Select",
      "\tselect {",
      "\tcase msg := <-ch1:",
      "\t\tfmt.Println(\"Received from ch1:\", msg)",
      "\tcase msg := <-ch2:",
      "\t\tfmt.Println(\"Received from ch2:\", msg)",
      "\t}",
      "}"
    ],
    "description": "Select Goroutine Pattern in Go"
  }
}
