{
  "decorator:create": {
    "prefix": "decorator",
    "body": [
      "import functools",
      "",
      "def decorator_name(func):",
      "\t@functools.wraps(func)",
      "\tdef wrapper(*args, **kwargs):",
      "\t\t# Pre-decorator actions if needed",
      "\t\tresult = func(*args, **kwargs)",
      "\t\t# Post-decorator actions if needed",
      "\t\treturn result",
      "\treturn wrapper",
      "",
      "@decorator_name",
      "def ${1:function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create a Python decorator"
  },
  "decorator:async decorator": {
    "prefix": "decorator_with_async",
    "body": [
      "import functools",
      "",
      "def async_decorator_name(func):",
      "\t@functools.wraps(func)",
      "\tasync def wrapper(*args, **kwargs):",
      "\t\t# Pre-decorator actions if needed",
      "\t\tresult = await func(*args, **kwargs)",
      "\t\t# Post-decorator actions if needed",
      "\t\treturn result",
      "\treturn wrapper",
      "",
      "@async_decorator_name",
      "async def ${1:async_function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create an async Python decorator"
  },
  "decorator:with parameter": {
    "prefix": "decorator_with_param",
    "body": [
      "import functools",
      "",
      "def decorator_name_with_param(param):",
      "\tdef decorator(func):",
      "\t\t@functools.wraps(func)",
      "\t\tdef wrapper(*args, **kwargs):",
      "\t\t\t# Pre-decorator actions with param if needed",
      "\t\t\tresult = func(*args, **kwargs)",
      "\t\t\t# Post-decorator actions with param if needed",
      "\t\t\treturn result",
      "\t\treturn wrapper",
      "\treturn decorator",
      "",
      "@decorator_name_with_param(${1:param_value})",
      "def ${2:function_name}(${3:parameters}):",
      "\t\"\"\"${4:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create a Python decorator with parameter"
  },
  "decorator:async decorator with Parameter": {
    "prefix": "decorator_async_with_param",
    "body": [
      "import functools",
      "",
      "def async_decorator_name_with_param(param):",
      "\tdef decorator(func):",
      "\t\t@functools.wraps(func)",
      "\t\tasync def wrapper(*args, **kwargs):",
      "\t\t\t# Pre-decorator actions with param if needed",
      "\t\t\tresult = await func(*args, **kwargs)",
      "\t\t\t# Post-decorator actions with param if needed",
      "\t\t\treturn result",
      "\t\treturn wrapper",
      "\treturn decorator",
      "",
      "@async_decorator_name_with_param(${1:param_value})",
      "async def ${2:async_function_name}(${3:parameters}):",
      "\t\"\"\"${4:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create an async Python decorator with parameter"
  },
  "decorator:t:create": {
    "prefix": "decorator_t_create",
    "body": ["@${1:decoratorName}"],
    "description": "Create an decorator tag"
  },
  "decorator:t:create_param": {
    "prefix": "decorator_t_param",
    "body": ["@${1:decoratorName}(${2:decoratorParam})"],
    "description": "Create an decorator tag with parameter"
  },
  "decorator:template:logging": {
    "prefix": "decorator_template_log",
    "body": [
      "import functools",
      "import logging",
      "",
      "def log_decorator(func):",
      "\t@functools.wraps(func)",
      "\tdef wrapper(*args, **kwargs):",
      "\t\tlogging.info('Calling function: %s', func.__name__)",
      "\t\tresult = func(*args, **kwargs)",
      "\t\tlogging.info('Function %s returned: %s', func.__name__, result)",
      "\t\treturn result",
      "\treturn wrapper",
      "",
      "@log_decorator",
      "def ${1:function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create a Python logging decorator"
  },
  "decorator:template:async logging decorator": {
    "prefix": "decorator_template_async_log",
    "body": [
      "import functools",
      "import logging",
      "",
      "def async_log_decorator(func):",
      "\t@functools.wraps(func)",
      "\tasync def wrapper(*args, **kwargs):",
      "\t\tlogging.info('Calling async function: %s', func.__name__)",
      "\t\tresult = await func(*args, **kwargs)",
      "\t\tlogging.info('Async function %s returned: %s', func.__name__, result)",
      "\t\treturn result",
      "\treturn wrapper",
      "",
      "@async_log_decorator",
      "async def ${1:async_function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create an async Python logging decorator"
  },
  "decorator:template:execution time decorator": {
    "prefix": "decorator_template_time",
    "body": [
      "import functools",
      "import time",
      "",
      "def time_decorator(func):",
      "\t@functools.wraps(func)",
      "\tdef wrapper(*args, **kwargs):",
      "\t\tstart_time = time.time()",
      "\t\tresult = func(*args, **kwargs)",
      "\t\tend_time = time.time()",
      "\t\texecution_time = end_time - start_time",
      "\t\tprint(f'Function {func.__name__} executed in {execution_time:.4f} seconds')",
      "\t\treturn result",
      "\treturn wrapper",
      "",
      "@time_decorator",
      "def ${1:function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create a Python execution time decorator"
  },
  "decorator:template:async execution time decorator": {
    "prefix": "decorator_tempalte_async_time",
    "body": [
      "import functools",
      "import time",
      "",
      "def async_time_decorator(func):",
      "\t@functools.wraps(func)",
      "\tasync def wrapper(*args, **kwargs):",
      "\t\tstart_time = time.time()",
      "\t\tresult = await func(*args, **kwargs)",
      "\t\tend_time = time.time()",
      "\t\texecution_time = end_time - start_time",
      "\t\tprint(f'Async function {func.__name__} executed in {execution_time:.4f} seconds')",
      "\t\treturn result",
      "\treturn wrapper",
      "",
      "@async_time_decorator",
      "async def ${1:async_function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create an async Python execution time decorator"
  },
  "decorator:template:retry decorator": {
    "prefix": "decorator_template_retry",
    "body": [
      "import functools",
      "import time",
      "",
      "def retry_decorator(max_attempts=3, delay=1):",
      "\tdef decorator(func):",
      "\t\t@functools.wraps(func)",
      "\t\tdef wrapper(*args, **kwargs):",
      "\t\t\tattempts = 0",
      "\t\t\twhile attempts < max_attempts:",
      "\t\t\t\ttry:",
      "\t\t\t\t\treturn func(*args, **kwargs)",
      "\t\t\t\texcept Exception as e:",
      "\t\t\t\t\tprint(f'Attempt {attempts + 1} failed:', str(e))",
      "\t\t\t\t\tattempts += 1",
      "\t\t\t\t\tif attempts < max_attempts:",
      "\t\t\t\t\t\ttime.sleep(delay)",
      "\t\t\t\telse:",
      "\t\t\t\t\t\traise",
      "\t\t\treturn None  # or handle failure scenario",
      "\t\treturn wrapper",
      "\treturn decorator",
      "",
      "@retry_decorator(max_attempts=5, delay=2)",
      "def ${1:function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create a Python retry decorator"
  },
  "decorator:template:async retry decorator": {
    "prefix": "decorator_template_async_retry",
    "body": [
      "import functools",
      "import asyncio",
      "",
      "def async_retry_decorator(max_attempts=3, delay=1):",
      "\tdef decorator(func):",
      "\t\t@functools.wraps(func)",
      "\t\tasync def wrapper(*args, **kwargs):",
      "\t\t\tattempts = 0",
      "\t\t\twhile attempts < max_attempts:",
      "\t\t\t\ttry:",
      "\t\t\t\t\treturn await func(*args, **kwargs)",
      "\t\t\t\texcept Exception as e:",
      "\t\t\t\t\tprint(f'Attempt {attempts + 1} failed:', str(e))",
      "\t\t\t\t\tattempts += 1",
      "\t\t\t\t\tif attempts < max_attempts:",
      "\t\t\t\t\t\tawait asyncio.sleep(delay)",
      "\t\t\t\telse:",
      "\t\t\t\t\t\traise",
      "\t\t\treturn None  # or handle failure scenario",
      "\t\treturn wrapper",
      "\treturn decorator",
      "",
      "@async_retry_decorator(max_attempts=5, delay=2)",
      "async def ${1:async_function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create an async Python retry decorator"
  },
  "decorator:template:throttle decorator": {
    "prefix": "decorator_template_throttle",
    "body": [
      "import functools",
      "import time",
      "",
      "def throttle_decorator(limit_per_second):",
      "\tdef decorator(func):",
      "\t\t@functools.wraps(func)",
      "\t\tdef wrapper(*args, **kwargs):",
      "\t\t\tif not hasattr(wrapper, 'last_call') or time.time() - wrapper.last_call >= 1 / limit_per_second:",
      "\t\t\t\tresult = func(*args, **kwargs)",
      "\t\t\t\twrapper.last_call = time.time()",
      "\t\t\t\treturn result",
      "\t\t\telse:",
      "\t\t\t\tprint(f'Call throttled. Limit reached for {func.__name__}')",
      "\t\t\t\treturn None  # or handle throttling scenario",
      "\t\treturn wrapper",
      "\treturn decorator",
      "",
      "@throttle_decorator(limit_per_second=5)",
      "def ${1:function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create a Python throttle decorator"
  },
  "decorator:template:async throttle decorator": {
    "prefix": "decorator_template_async_throttle",
    "body": [
      "import functools",
      "import asyncio",
      "",
      "def async_throttle_decorator(limit_per_second):",
      "\tdef decorator(func):",
      "\t\t@functools.wraps(func)",
      "\t\tasync def wrapper(*args, **kwargs):",
      "\t\t\tif not hasattr(wrapper, 'last_call') or time.time() - wrapper.last_call >= 1 / limit_per_second:",
      "\t\t\t\tresult = await func(*args, **kwargs)",
      "\t\t\t\twrapper.last_call = time.time()",
      "\t\t\t\treturn result",
      "\t\t\telse:",
      "\t\t\t\tprint(f'Call throttled. Limit reached for {func.__name__}')",
      "\t\t\t\treturn None  # or handle throttling scenario",
      "\t\treturn wrapper",
      "\treturn decorator",
      "",
      "@async_throttle_decorator(limit_per_second=5)",
      "async def ${1:async_function_name}(${2:parameters}):",
      "\t\"\"\"${3:Docstring}\"\"\"",
      "\t${0:# code here}"
    ],
    "description": "Create an async Python throttle decorator"
  }
}
