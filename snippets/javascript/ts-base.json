{
  "TODO": {
    "prefix": "todo_",
    "body": ["// TODO: $0"],
    "description": "// TODO: ..."
  },
  "WARN": {
    "prefix": "warn_",
    "body": ["// WARN: $0"],
    "description": "// WARN: ..."
  },
  "lorem ipsum sedang": {
    "prefix": "lorem",
    "body": [
      "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras aliquam est ac ipsum posuere, quis venenatis sem fermentum. Morbi nec nisi at lorem placerat vehicula."
    ],
    "description": "Menyisipkan teks Lorem Ipsum sedang."
  },
  "lorem ipsum panjang": {
    "prefix": "lorem5",
    "body": [
      "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras aliquam est ac ipsum posuere, quis venenatis sem fermentum. Morbi nec nisi at lorem placerat vehicula.",
      "",
      "Sed eu turpis vitae risus eleifend efficitur. Nam tincidunt ultricies eros, eget facilisis orci molestie et. Aenean sagittis, magna eget vestibulum varius, odio ipsum consequat risus, a condimentum leo sapien sit amet lorem.",
      "",
      "Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vivamus finibus, felis in tincidunt tincidunt, nulla ex lacinia quam, non ultricies enim felis in tellus.",
      "",
      "Fusce ullamcorper interdum erat, sit amet scelerisque est eleifend vel. Integer rhoncus, felis in posuere lacinia, neque nisi eleifend nisl, id convallis libero sapien vitae purus."
    ],
    "description": "Menyisipkan teks Lorem Ipsum panjang (5 paragraf)."
  },
  "use strict": {
    "prefix": "use_strict",
    "body": "'use strict'",
    "description": "use strict"
  },
  "require": {
    "prefix": "req_",
    "body": "require('${1:module}')",
    "description": "require(\"module\")"
  },
  "export:named declaration": {
    "prefix": "export_",
    "body": ["export { ${1:exportedName} };", "$0"],
    "description": "Declare a named export in TypeScript"
  },
  "export:member": {
    "prefix": "export_member",
    "body": "exports.${1:member} = ${2:value}",
    "description": "exports.member = value"
  },
  "export:const:named;function": {
    "prefix": "export_const_func",
    "body": ["export const ${1:first} = (${2:second}) => {${3:third}}"],
    "description": "Export named function"
  },
  "export:default function": {
    "prefix": "edf",
    "body": ["export default (${1:first}) => {${2:second}}"],
    "description": "Export default function"
  },
  "export:default:namedfunction": {
    "prefix": "ednf",
    "body": ["export default function ${1:first}(${2:second}) {${3:third}}"],
    "description": "Export default named function"
  },
  "export:as from": {
    "prefix": "export_as_from",
    "body": ["export { ${2:second} as ${3:third} } from '${1:first}'"]
  },
  "export:default:declaration": {
    "prefix": "export_default",
    "body": ["export default ${1:expression};", "$0"],
    "description": "Declare a default export in TypeScript"
  },
  "module:exports": {
    "prefix": "module_exports",
    "body": "module.exports = ${1:name}",
    "description": "module.exports = name"
  },
  "module:ambient:declaration": {
    "prefix": "module_ambient",
    "body": ["declare module '${1:moduleName}' {", "\t$0", "}"],

    "description": "Declare an ambient module in TypeScript"
  },
  "module:define": {
    "prefix": "module_define",
    "body": [
      "define([",
      "\t'require',",
      "\t'${1:dependency}'",
      "], function(require, ${2:factory}) {",
      "\t'use strict';",
      "\t$0",
      "});"
    ],
    "description": [
      "define([",
      "\t'require',",
      "\t'${1:dependency}'",
      "], function(require, ${2:factory}) {",
      "\t'use strict';",
      "\t$0",
      "});"
    ]
  },
  "namespace:declaration": {
    "prefix": "namespace_",
    "body": ["namespace ${1:NamespaceName} {", "\t$0", "}"],
    "description": "Declare a namespace in TypeScript"
  },
  "namespace:module export": {
    "prefix": "namespace_export",
    "body": ["export namespace ${1:NamespaceName} {", "\t$0", "}"],
    "description": "Export a namespace module in TypeScript"
  },
  "import:create": {
    "prefix": "imp_",
    "body": ["import '${1:first}'"]
  },
  "import:module destructured": {
    "prefix": "imp_from",
    "body": "import {$2} from '${1:module}'",
    "description": "import value from 'module'"
  },
  "import:statement": {
    "prefix": "imp_from_desctructing",
    "body": ["import { ${1:importedName} } from '${2:module}';", "$0"],
    "description": "Import statement in TypeScript"
  },
  "import:destructing": {
    "prefix": "imp_from_as_destructing",
    "body": ["import { ${2:second} } from '${1:first}'"]
  },
  "import:module as": {
    "prefix": "imp_from_as",
    "body": "import ${2:*} as ${3:name} from '${1:module}'",
    "description": "import * as name from 'module'"
  },
  "import:default statement": {
    "prefix": "imp_from_default",
    "body": ["import ${1:defaultName} from '${2:module}';", "$0"],
    "description": "Import default statement in TypeScript"
  },
  "import:all statement": {
    "prefix": "imp_from_all",
    "body": ["import * as ${1:namespace} from '${2:module}';", "$0"],
    "description": "Import all statement in TypeScript"
  },
  "const:statement": {
    "prefix": "const_",
    "body": "const ${1:name} = ${0}",
    "description": "const name"
  },
  "const:array": {
    "prefix": "const_array",
    "body": ["const ${1:arrayName}: ${2:Type}[] = [${3}]$0;"]
  },
  "const:array emtpy": {
    "prefix": "const_array_empty",
    "body": ["const ${1:arrayName}: ${2:Type}[] = [];", "$0"],
    "description": "Declare an empty array in TypeScript"
  },
  "const:object": {
    "prefix": "const_obj",
    "body": [
      "const ${1:objName}: { ${2:key}: ${3:Type} } = { ${2:key}: ${4:value} }$0;"
    ],
    "description": "Declare an object in TypeScript"
  },
  "const:object empty": {
    "prefix": "const_obj_empty",
    "body": ["const ${1:objName}: { ${2:key}: ${3:Type} } = {};", "$0"],
    "description": "Declare an empty object in TypeScript"
  },
  "const:map": {
    "prefix": "const_map",
    "body": [
      "const ${1:mapName}: Map<${2:KeyType}, ${3:ValueType}> = new Map();$0"
    ],
    "description": "Declare a Map in TypeScript"
  },
  "const:map empty": {
    "prefix": "const_map_empty",
    "body": [
      "const ${1:mapName}: Map<${2:KeyType}, ${3:ValueType}> = new Map();",
      "$0"
    ],
    "description": "Declare an empty Map in TypeScript"
  },
  "const:set": {
    "prefix": "const_set",
    "body": ["const ${1:setName}: Set<${2:Type}> = new Set([${3}]);$0"],
    "description": "Declare a Set in TypeScript"
  },
  "const:set empty": {
    "prefix": "const_set_empty",
    "body": ["const ${1:setName}: Set<${2:Type}> = new Set();", "$0"],
    "description": "Declare an empty Set in TypeScript"
  },
  "const:tuple": {
    "prefix": "const_tuple",
    "body": [
      "let ${1:tupleName}: [${2:Type1}, ${3:Type2}] = [${4:value1}, ${5:value2}];$0"
    ],
    "description": "Declare a tuple in TypeScript"
  },
  "const:ternary assignment": {
    "prefix": "const_ternary",
    "body": "const ${0} = ${1:cond} ? ${2:true} : ${3:false}",
    "description": "const ${0} = ${1:cond} ? ${2:true} : ${3:false}"
  },
  "const:destructuring:statement": {
    "prefix": "const_destructuring",
    "body": "const { ${2:prop} } = ${1:value}",
    "description": "const { prop } = value"
  },
  "const:destructuring:statement from array": {
    "prefix": "const_array_d",
    "body": "const [ ${2:prop} ] = ${1:value}",
    "description": "const [ prop ] = value"
  },
  "const:destructuring:statement awaited": {
    "prefix": "cosnt_a_d",
    "body": "const { ${1:name} } = await ${2:value}",
    "description": "const { name } = await value"
  },
  "const:date object declaration": {
    "prefix": "const_date",
    "body": ["const ${1:dateName}: Date = new Date();", "$0"],
    "description": "Declare a Date object in TypeScript"
  },
  "const:regexp object declaration": {
    "prefix": "const_regexp",
    "body": ["const ${1:regexName}: RegExp = /${2:pattern}/;", "$0"],
    "description": "Declare a RegExp object in TypeScript"
  },
  "const:template literal": {
    "prefix": "const_string_template",
    "body": ["const ${1:variable}: string = `${2:expression}`;", "$0"],
    "description": "Declare a template literal in TypeScript"
  },
  "const:obj class": {
    "prefix": "const_obj_class",
    "body": ["const ${1:name} = new ${2:type}(${3:arguments});$0"],
    "description": "const name = new type(arguments);"
  },
  "const:assignment awaited": {
    "prefix": "const_await",
    "body": "const ${1:name} = await ${2:value}",
    "description": "const name = await value"
  },
  "const:assignment yielded": {
    "prefix": "const_yield",
    "body": "const ${1:name} = yield ${2:value}",
    "description": "const name = yield value"
  },
  "const:require module": {
    "prefix": "const_require",
    "body": "const ${1:module} = require('${1:module}')",
    "description": "const module = require('module')"
  },
  "const:export member value": {
    "prefix": "const_export",
    "body": "export const ${1:member} = ${2:value}",
    "description": "export const member = value"
  },
  "chaining:optional chaining": {
    "prefix": "chaining_optional",
    "body": ["${1:object}.${2:property}?.${3:subproperty};", "$0"],
    "description": "Use optional chaining operator in TypeScript"
  },
  "chaining:nullish coalescing operator": {
    "prefix": "chaining_nullish",
    "body": ["${1:variable} ?? ${2:defaultValue};", "$0"],
    "description": "Use nullish coalescing operator in TypeScript"
  },
  "const:spread operator (array)": {
    "prefix": "const_spread_array",
    "body": [
      "const ${1:arrayName}: ${2:Type}[] = [...${3:sourceArray}];",
      "$0"
    ],
    "description": "Use spread operator for arrays in TypeScript"
  },
  "const:spread operator (object)": {
    "prefix": "const_spread_object",
    "body": [
      "const ${1:objName}: { ...${2:sourceObject} } = { ...${2:sourceObject} };",
      "$0"
    ],
    "description": "Use spread operator for objects in TypeScript"
  },
  "const:array:destructuring": {
    "prefix": "const_array_destructuring",
    "body": ["const [${1:elem1}, ${2:elem2}] = ${3:sourceArray};", "$0"],
    "description": "Destructuring assignment for arrays in TypeScript"
  },
  "const:object:destructuring": {
    "prefix": "const_object_destructuring",
    "body": ["const { ${1:key1}, ${2:key2} } = ${3:sourceObject};", "$0"],
    "description": "Destructuring assignment for objects in TypeScript"
  },
  "const:assertion:type casting": {
    "prefix": "const_type_assertion",
    "body": ["const ${1:typed_variable} = ${2:variable} as ${3:Type};"],
    "description": "Type assertion (type casting) in TypeScript"
  },
  "const:assertion:for type aliases": {
    "prefix": "const_type_assertion_as_alias_variable",
    "body": [
      "type ${1:TypeAlias} = ${2:Type};",
      "const ${3:variable}: ${1:TypeAlias} = ${4:value} as ${1:TypeAlias};"
    ],
    "description": "Type assertion for type aliases in TypeScript"
  },
  "const:assertion:with optional chaining": {
    "prefix": "const_type_assertion_optional_chaining",
    "body": ["const ${1:value} = ${2:object}?.${3:property} as ${4:Type};"],
    "description": "Type assertion for optional chaining in TypeScript"
  },
  "const:assertion:for using 'as const'": {
    "prefix": "const_type_assertion_as_const",
    "body": [
      "const ${1:array}: readonly ${2:ArrayType}[] = ${3:values} as const;"
    ],
    "description": "Type assertion for using 'as const' in TypeScript"
  },
  "const:assertion:for array element": {
    "prefix": "const_type_assertion_array_element",
    "body": [
      "const ${1:result} = (${2:array}[${3:index}]) as ${4:ElementType};"
    ],
    "description": "Type assertion for array element in TypeScript"
  },
  "const:assertion:for array elements": {
    "prefix": "const_type_assertion_check_array_elements",
    "body": [
      "const ${1:result} = ${2:array}.map((${3:item}) => ${3:item} as ${4:ElementType});"
    ],
    "description": "Type checking for array elements in TypeScript"
  },
  "const:check:for object properties (with optional properties)": {
    "prefix": "const_check_object_properties_optional",
    "body": [
      "const ${1:object}: { ${2:property1}: ${3:Type1}, ${4:property2}?: ${5:Type2} } = {",
      "    ${2:property1}: ${6:value1}",
      "};"
    ],
    "description": "Type checking for object properties with optional properties in TypeScript"
  },
  "var:global variable declaration": {
    "prefix": "var_global",
    "body": [
      "declare global {",
      "\tvar ${1:globalVariable}: ${2:Type};",
      "}",
      "$0"
    ],
    "description": "Declare a global variable in TypeScript"
  },
  "let:statement": {
    "prefix": "let_",
    "body": "let ${1:name} = $0",
    "description": "let name"
  },
  "let:assignment awaited": {
    "prefix": "let_await",
    "body": "let ${1:name} = await ${2:value}",
    "description": "let name = await value"
  },
  "let:assignment yielded": {
    "prefix": "let_yield",
    "body": "let ${1:name} = yield ${2:value}",
    "description": "let name = yield value"
  },
  "typeof": {
    "prefix": "typeof_",
    "body": "typeof ${1:source} === '${2:undefined}'",
    "description": "typeof source === 'undefined'"
  },
  "instanceof": {
    "prefix": "instanceof_",
    "body": "${1:source} instanceof ${2:Object}",
    "description": "value instanceof Myclass"
  },
  "prototype method": {
    "prefix": "prototype_",
    "body": "${1:Class}.prototype.${2:method} = function (${3:arguments}) {\n\t${0}\n}",
    "description": "Class.prototype.method = function (arguments) {\n\n}"
  },
  "ternary": {
    "prefix": "tern_",
    "body": "${1:cond} ? ${2:true} : ${3:false}",
    "description": "cond ? true : false"
  },
  "ternary:multi-line ternary operator": {
    "prefix": "tern_multi_line",
    "body": [
      "${1:condition}",
      "\t? (",
      "\t\t${2:valueIfTrue},",
      "\t) : (",
      "\t\t${3:valueIfFalse}",
      "\t)"
    ],
    "description": "Multi-line ternary operator"
  },
  "ternary:complex condition": {
    "prefix": "tern_complex_condition",
    "body": [
      "(${1:condition1} && ${2:condition2})",
      "\t? ${3:valueIfTrue}",
      "\t: ${4:valueIfFalse}"
    ],
    "description": "Ternary operator with complex condition"
  },
  "ternary:complex expression": {
    "prefix": "tern_complex_expression",
    "body": [
      "${1:condition} ? (${2:expressionIfTrue}) : (${3:expressionIfFalse})"
    ],
    "description": "Ternary operator with complex expression"
  },
  "ternary:optional chaining and nullish coalescing": {
    "prefix": "tern_optional_nullish_coalescing",
    "body": ["${1:object}?.${2:property} ?? ${3:defaultValue}"],
    "description": "Ternary operator with optional chaining and nullish coalescing"
  },
  "return:create": {
    "prefix": "ret_",
    "body": "return (${1:arguments}) => ${2:statement}",
    "description": "return (arguments) => statement"
  },
  "return:type assertion": {
    "prefix": "ret_type_assertion",
    "body": ["return ${3:result} as ${2:ReturnType};"],
    "description": "Type assertion for function return type in TypeScript"
  },
  "return:arrow function": {
    "prefix": "ret_func_arrow",
    "body": "return (${1:arguments}) => ${2:statement}",
    "description": "return (arguments) => statement"
  },
  "return:this": {
    "prefix": "ret_this",
    "body": "return ${0:this}",
    "description": "return this"
  },
  "return:null": {
    "prefix": "ret_null",
    "body": "return null",
    "description": "return null"
  },
  "return:array": {
    "prefix": "ret_array",
    "body": "return [\n\t${0}\n]",
    "description": "return [\n\n]"
  },
  "return:object literal": {
    "prefix": "ret_obj_literal",
    "body": ["return {", "\t${1:key}: ${2:value},", "};"],
    "description": "Return an object literal"
  },
  "return:new Promise": {
    "prefix": "ret_new_promise",
    "body": [
      "return new Promise((${1:resolve}, ${2:reject}) => {",
      "\t${3:// Write async code here}",
      "\t$1(${4:result});",
      "});"
    ],
    "description": "Return a Promise"
  },
  "return:async return": {
    "prefix": "ret_async_await",
    "body": ["return await ${1:expression};"],
    "description": "Async return statement"
  },
  "return:conditional": {
    "prefix": "ret_conditional",
    "body": ["return ${1:condition} ? ${2:valueIfTrue} : ${3:valueIfFalse};"],
    "description": "Return statement with conditional expression"
  },
  "return:statement with default value": {
    "prefix": "ret_default",
    "body": [
      "return ${1:value} !== undefined ? ${1:value} : ${2:defaultValue};"
    ],
    "description": "Return statement with default value"
  },
  "return:statement with interface": {
    "prefix": "ret_interface",
    "body": [
      "return ${1:{",
      "\t${2:key1}: ${3:type1};",
      "\t${4:key2}: ${5:type2};",
      "}};"
    ],
    "description": "Return statement with TypeScript interface"
  },
  "return:statement with destructuring": {
    "prefix": "ret_destructuring",
    "body": ["return { ${1:key1}, ${2:key2} } = ${3:value};"],
    "description": "Return statement with destructuring"
  },
  "return:statement with optional chaining": {
    "prefix": "ret_optional",
    "body": ["return ${1:object}?.${2:property};"],
    "description": "Return statement with optional chaining"
  },
  "return:statement with nullish coalescing": {
    "prefix": "ret_nullish",
    "body": ["return ${1:value} ?? ${2:defaultValue};"],
    "description": "Return statement with nullish coalescing"
  },
  "return:statement with tuple type": {
    "prefix": "ret_tuple",
    "body": ["return [${1:value1}, ${2:value2}] as [${3:type1}, ${4:type2}];"],
    "description": "Return statement with tuple type"
  },
  "return:statement with type assertion": {
    "prefix": "ret_assertion",
    "body": ["return ${1:value} as ${2:type};"],
    "description": "Return statement with type assertion"
  },
  "for": {
    "prefix": "for_",
    "body": [
      "for (let ${1:index} = 0; ${1:index} < ${2:array}.length; ${1:index}++) {",
      "\tconst ${3:element} = ${2:array}[${1:index}];",
      "\t$0",
      "}"
    ],
    "description": [
      "for (let index = 0; index < array.length; index++) {",
      "\tconst element = array\\[index\\];",
      "\t$0",
      "}"
    ]
  },
  "for:in": {
    "prefix": "for_in",
    "body": [
      "for (const ${1:key} in ${2:object}) {",
      "\tif (${2:object}.hasOwnProperty(${1:key})) {",
      "\t\tconst ${3:element} = ${2:object}[${1:key}];",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": [
      "for (const key in object) {",
      "\tif (object.hasOwnProperty(key)) {",
      "\t\tconst element = object\\[key\\];",
      "",
      "\t}",
      "}"
    ]
  },
  "for:of": {
    "prefix": "for_of",
    "body": ["for (const ${1:iterator} of ${2:myarray}) {", "\t$0", "}"],
    "description": ["for (const iterator of array) {", "", "}"]
  },
  "for:await-of loop": {
    "prefix": "for_of_await",
    "body": [
      "for await (const ${1:iterator} of ${2:object}) {",
      "\t$TM_SELECTED_TEXT$0",
      "}"
    ],
    "description": "For-Await-Of Loop"
  },
  "for:each": {
    "prefix": "for_each",
    "body": ["${1:array}.forEach(${2:element} => {", "\t$0", "});"],
    "description": "Create a for loop for each element"
  },
  "function": {
    "prefix": "func_",
    "body": ["function ${1:name}(${2:params}) {", "\t$0", "}"],
    "description": "Create a function"
  },
  "function:expr": {
    "prefix": "func_expr_",
    "body": [
      "const ${1:functionName} = function (${2:parameters}): ${3:returnType} {",
      "  ${4:// TODO: implement function}",
      "  return ${5:result};",
      "};"
    ],
    "description": "Create a traditional function expression in TypeScript"
  },
  "function:expr arrow": {
    "prefix": "func_expr_arrow",
    "body": [
      "const ${1:functionName} = (${2:parameters}): ${3:returnType} => {",
      "  ${4:// TODO: implement function}",
      "  return ${5:result};",
      "};"
    ],
    "description": "Create a function expression in TypeScript"
  },
  "function:anonymous": {
    "prefix": "func_anon",
    "body": "function (${1:arguments}) {${0}}",
    "description": "Create a anonymous function"
  },
  "function:anonymous arrow": {
    "prefix": "func_anon_arrow",
    "body": "(${1:arguments}) => ${2:statement}",
    "description": "Create an anonymous arrow function"
  },
  "function:arrow with destructuring": {
    "prefix": "func_anon_arrow_with_param_desctructing",
    "body": "({${1:arguments}}) => ${2:statement}",
    "description": "Create an arrow function with destructuring"
  },
  "function:callback": {
    "prefix": "func_callback",
    "body": "function (err, ${1:value}) {\n\tif (err) throw err\n\t${0}\n}",
    "description": "Create a callback function"
  },
  "function:export named": {
    "prefix": "func_export",
    "body": "export function ${1:member} (${2:arguments}) {\n\t${0}\n}",
    "description": "Create a function export"
  },
  "function:param:optional": {
    "prefix": "func_param_optional",
    "body": [
      "function ${1:functionName}(${2:param1}: ${3:Type} = ${4:defaultValue}) {",
      "\t$0",
      "}"
    ],
    "description": "Declare a function with optional parameters in TypeScript"
  },
  "function:param:optional parameters": {
    "prefix": "func_param_optional_parameters",
    "body": [
      "function ${1:functionName}(${2:param1}: ${3:Type1}${4:=defaultValue1}, ${5:param2}?: ${6:Type2}) {",
      "    // Function body",
      "}"
    ],
    "description": "Type checking for function parameters with optional parameters in TypeScript"
  },
  "function:param:rest": {
    "prefix": "func_param_rest",
    "body": [
      "function ${1:functionName}(...${2:params}: ${3:Type}[]) {",
      "\t$0",
      "}"
    ],
    "description": "Declare a function with rest parameters in TypeScript"
  },
  "function:param:default": {
    "prefix": "func_param_default",
    "body": [
      "function ${1:functionName}(${2:param1}: ${3:Type} = ${4:defaultValue}) {",
      "\t$0",
      "}"
    ],
    "description": "Declare a function with default parameters in TypeScript"
  },
  "function:param:destructuring object": {
    "prefix": "func_param_destructuring_object",
    "body": [
      "function ${1:functionName}({ ${2:key1}, ${3:key2 }: ${4:Type} }) {",
      "\t$0",
      "}"
    ],
    "description": "Destructuring assignment for object function parameter in TypeScript"
  },
  "function:param:destructuring array": {
    "prefix": "func_param_destructuring_array",
    "body": [
      "function ${1:functionName}([${2:param1}, ${3:param2}]: ${4:Type}[]) {",
      "\t$0",
      "}"
    ],
    "description": "Destructuring assignment for array function parameter in TypeScript"
  },
  "function:generator:declaration": {
    "prefix": "func_generator",
    "body": [
      "function* ${1:functionName}() {",
      "\tyield ${2:value};",
      "}",
      "$0"
    ],
    "description": "Declare a generator function in TypeScript"
  },
  "function:immediately-invoked function expression": {
    "prefix": "func_iife",
    "body": ";(function (${1:arguments}) {\n\t${0}\n})(${2})",
    "description": "Create a func IIFE"
  },
  "function:module default export": {
    "prefix": "func_exp_default",
    "body": "export default ${1:member}",
    "description": "export default member"
  },
  "function:module default export function": {
    "prefix": "funct_exp_default_func",
    "body": "export default function ${1:name} (${2:arguments}) {\n\t${0}\n}",
    "description": "export default function nameFunc (arguments) {\n\t${0}\n}"
  },
  "function:void declaration": {
    "prefix": "func_void",
    "body": ["function ${1:functionName}(): void {", "\t$0", "}"],
    "description": "Declare a void function in TypeScript"
  },
  "function:assertion:for function return type (with union types)": {
    "prefix": "func_assertion_for_return",
    "body": [
      "function ${1:functionName}(): ${2:ReturnType1} | ${3:ReturnType2} {",
      "    return ${4:result} as ${2:ReturnType1} | ${3:ReturnType2};",
      "}"
    ],
    "description": "Type assertion for function return type with union types in TypeScript"
  },
  "function:assertion:checking with type assertion for unknown type": {
    "prefix": "func_assertion_for_unknown_type",
    "body": [
      "function assertIs${1:Type}(value: unknown): asserts value is ${1:Type} {",
      "    if (typeof value !== 'object' || value === null /* additional checks */) {",
      "        throw new Error(`Expected '${1:Type}' but received '${value}'`);",
      "    }",
      "}",
      "",
      "let ${2:value}: unknown = ${3:getValue}();",
      "assertIs${1:Type}(${2:value});",
      "// Now ${2:value} is of type ${1:Type}"
    ],
    "description": "Type checking with type assertion for unknown type in TypeScript"
  },
  "function:assertion:for function returning any": {
    "prefix": "func_assertion_for_ret_any",
    "body": [
      "function parseData(data: any): ${1:ParsedType} {",
      "    return ${2:parseFunction}(data) as ${1:ParsedType};",
      "}"
    ],
    "description": "Type assertion for function returning 'any' in TypeScript"
  },
  "function:check:for array operations with every and some": {
    "prefix": "func_check_array_operations_every_and_some",
    "body": [
      "const ${1:isValid1}: boolean = ${2:array}.every((${3:item}: ${4:ItemType}) => ${5:condition});",
      "const ${6:isValid2}: boolean = ${2:array}.some((${7:item}: ${8:ItemType}) => ${9:condition});"
    ],
    "description": "Type checking for array operations with 'every' and 'some' in TypeScript"
  },
  "function:check:for using 'never' type": {
    "prefix": "func_check_never_type",
    "body": [
      "function error(message: string): never {",
      "    throw new Error(message);",
      "}",
      "",
      "function validateValue(value: ${1:ValueType}) {",
      "    if (${2:condition}) {",
      "        return value;",
      "    } else {",
      "        return error('${3:Invalid value}');",
      "    }",
      "}"
    ],
    "description": "Type checking for using 'never' type in TypeScript"
  },
  "function:check:in array operations": {
    "prefix": "func_check_array_operations",
    "body": [
      "const ${1:result} = ${2:array}.filter(${3:(item: ${4:ItemType}) => ${5:boolean}});"
    ],
    "description": "Type checking in array operations in TypeScript"
  },
  "function:check:with guard function": {
    "prefix": "func_check_with_function_guard",
    "body": [
      "function is${1:Type}(obj: any): obj is ${1:Type} {",
      "\treturn typeof obj === 'object' && obj !== null /* add specific checks */;",
      "}",
      "",
      "if (is${1:Type}(${2:variable})) {",
      "\t// ${2:variable} is of type ${1:Type}",
      "} else {",
      "\t// ${2:variable} is not of type ${1:Type}",
      "}"
    ],
    "description": "Type guard function for checking TypeScript types"
  },
  "function:check:guard for object properties": {
    "prefix": "func_check_object_properties_guard",
    "body": [
      "interface ${1:ObjectType} {",
      "    ${2:property1}: ${3:Type1};",
      "    ${4:property2}: ${5:Type2};",
      "}",
      "",
      "function hasProperty(obj: any, prop: string): obj is ${1:ObjectType} {",
      "    return typeof obj === 'object' && obj !== null && '${2:property1}' in obj && '${4:property2}' in obj;",
      "}",
      "",
      "const ${6:obj}: any = ${7:getObject}();",
      "if (hasProperty(${6:obj}, '${2:property1}') && hasProperty(${6:obj}, '${4:property2}')) {",
      "    // ${6:obj} has properties ${2:property1} of type ${3:Type1} and ${4:property2} of type ${5:Type2}",
      "} else {",
      "    // ${6:obj} does not have expected properties",
      "}"
    ],
    "description": "Type guard for object properties in TypeScript"
  },
  "function:check:guard for null and undefined": {
    "prefix": "func_check_null_and_undefined_guard",
    "body": [
      "function isNotNullOrUndefined<T>(arg: T | null | undefined): arg is T {",
      "    return arg !== null && arg !== undefined;",
      "}",
      "",
      "const ${1:variable}: ${2:Type} | null | undefined = ${3:getValue}();",
      "if (isNotNullOrUndefined(${1:variable})) {",
      "    // ${1:variable} is of type ${2:Type}",
      "} else {",
      "    // ${1:variable} is null or undefined",
      "}"
    ],
    "description": "Type guard for null and undefined in TypeScript"
  },
  "if": {
    "prefix": "if_",
    "body": ["if (${1:condition}) {", "\t${0}", "}"],
    "description": ["if (${1:condition}) {", "", "}"]
  },
  "if:else": {
    "prefix": "if_else",
    "body": ["if (${1:condition}) {", "", "} else {", "", "}"],
    "description": ["if (condition) {", "\t$0", "} else {", "\t", "}"]
  },
  "if:elif": {
    "prefix": "if_elif",
    "body": "else if (${1:condition}) {\n\t${0}\n}",
    "description": "else if (condition) {\n\t${0}\n}"
  },
  "else": {
    "prefix": "else_",
    "body": "else {\n\t${0}\n}",
    "description": "else {\n\t${0}\n}"
  },
  "let and if statement": {
    "prefix": "let_if",
    "body": "let ${0} \n if (${2:condition}) {\n\t${1}\n}",
    "description": "let x \n if (condition) {\n\t${1}\n}"
  },
  "switch": {
    "prefix": "switch_",
    "body": [
      "switch (${1:key}) {",
      "\tcase ${2:value}:",
      "\t\t$0",
      "\t\tbreak;",
      "",
      "\tdefault:",
      "\t\tbreak;",
      "}"
    ],
    "description": [
      "switch (key) {",
      "\tcase value:",
      "",
      "\t\tbreak;",
      "",
      "\tdefault:",
      "\t\tbreak;",
      "}"
    ]
  },
  "switch:case:create": {
    "prefix": "switch_case",
    "body": ["case ${1:value}:", "\t$0", "\tbreak;"],
    "description": "Create a case statement"
  },
  "switch:case:with Fallthrough": {
    "prefix": "switch_case_fallthrough",
    "body": ["case ${1:value}:", "\t$0", "\t// fall through"],
    "description": "Create a case statement with fallthrough comment"
  },
  "switch:case:Enum Statement": {
    "prefix": "switch_case_enum",
    "body": ["case ${1:EnumName}.${2:Case}:", "\t$0", "\tbreak;"],
    "description": "Create a case statement for enum value"
  },
  "switch:case:String": {
    "prefix": "switch_case_string",
    "body": ["case '${1:value}':", "\t$0", "\tbreak;"],
    "description": "Create a case statement for string value"
  },
  "switch:case:Numeric Statement": {
    "prefix": "switch_case_numeric",
    "body": ["case ${1:number}:", "\t$0", "\tbreak;"],
    "description": "Create a case statement for numeric value"
  },
  "switch:case:Statement with Multiple Values": {
    "prefix": "switch_case_multiple",
    "body": ["case ${1:value1}:", "case ${2:value2}:", "\t$0", "\tbreak;"],
    "description": "Create a case statement with multiple values"
  },
  "switch:case:Conditional": {
    "prefix": "switch_case_conditional",
    "body": [
      "case ${1:value}:",
      "\tif (${2:condition}) {",
      "\t\t$0",
      "\t}",
      "\tbreak;"
    ],
    "description": "Create a case statement with a conditional check"
  },
  "switch:case:with Return": {
    "prefix": "swith_case_return",
    "body": ["case ${1:value}:", "\treturn ${2:result};"],
    "description": "Create a case statement with a return statement"
  },
  "switch:case:with Function Call": {
    "prefix": "switch_case_function_call",
    "body": ["case ${1:value}:", "\t${2:functionName}();", "\tbreak;"],
    "description": "Create a case statement with a function call"
  },
  "switch:case:with Object Property": {
    "prefix": "switch_case_object_property",
    "body": [
      "case ${1:value}:",
      "\tconst ${2:property} = ${3:object}.${1:value};",
      "\t$0",
      "\tbreak;"
    ],
    "description": "Create a case statement with object property access"
  },
  "while": {
    "prefix": "while_",
    "body": ["while (${1:condition}) {", "\t$0", "}"],
    "description": ["while (condition) {", "", "}"]
  },
  "while:iteration from array length": {
    "prefix": "while_iteration_decrementing",
    "body": "let ${1:array}Index = ${1:array}.length\nwhile (${1:array}Index--) {\n\t${0}\n}",
    "description": "let arrayIndex = array.length\nwhile (arrayIndex--) {\n\n}"
  },
  "while:do Statement": {
    "prefix": "do_while",
    "body": ["do {", "\t$0", "} while (${1:condition});"],
    "description": ["do {", "\t$0", "} while (condition);"]
  },
  "try:catch Statement": {
    "prefix": "try_catch",
    "body": ["try {", "\t$0", "} catch (${1:error}) {", "\t", "}"],
    "description": ["try {", "\t$0", "} catch (error) {", "\t", "}"]
  },
  "try:finally": {
    "prefix": "try_finally",
    "body": "try {\n\t${0}\n} finally {\n\t\n}",
    "description": "try {\n\n} finally {\n\n}"
  },
  "try:catch:finally": {
    "prefix": "try_catch_finally",
    "body": "try {\n\t${0}\n} catch (${1:err}) {\n\t\n} finally {\n\t\n}",
    "description": "try {\n\n} catch (err) {\n\n} finally {\n\n}"
  },
  "process.env": {
    "prefix": "process_env",
    "body": "process.env",
    "description": "process.env"
  },
  "before": {
    "prefix": "before_",
    "body": "before(async () => {\n\t${0}\n})",
    "description": "before(async () => {\n\n})"
  },
  "beforeAll": {
    "prefix": "before_all",
    "body": "beforeAll(async () => {\n\t${0}\n})",
    "description": "beforeAll(async () => {\n\n})"
  },
  "beforeEach": {
    "prefix": "before_each",
    "body": "beforeEach(async () => {\n\t${0}\n})",
    "description": "beforeEach(async () => {\n\n})"
  },
  "after": {
    "prefix": "after_",
    "body": "after(() => {\n\t${0}\n})",
    "description": "after(() => {\n\n})"
  },
  "afterEach": {
    "prefix": "after_each",
    "body": "afterEach(() => {\n\t${0}\n})",
    "description": "afterEach(() => {\n\n})"
  },
  "set:immediate": {
    "prefix": "set_immediate",
    "body": "setImmediate(() => {\n\t${0}\n})",
    "description": "setImmediate(() => {\n\n})"
  },
  "set:timeout": {
    "prefix": "set_timeout",
    "body": ["setTimeout(() => {", "\t$0", "}, ${1:timeout});"],
    "description": "Set Timeout Function"
  },
  "set:interval": {
    "prefix": "set_interval",
    "body": ["setInterval(() => {", "\t$0", "}, ${1:interval});"],
    "description": ["setInterval(() => {", "\t", "}, ${1:interval});"]
  },
  "type alias declaration": {
    "prefix": "type_alias",
    "body": ["type ${1:AliasName} = ${2:Type};$0"],
    "description": "Declare a type alias in TypeScript"
  },
  "enum:create:with auto increment": {
    "prefix": "enum_with_auto_inc",
    "body": [
      "enum ${1:EnumName} {",
      "\t${2:Sunday},",
      "\t${3:Monday},",
      "\t${4:Tuesday}",
      "}"
    ],
    "description": "Create an enum with auto-incrementing values"
  },
  "enum:create:with member": {
    "prefix": "enum_with_member_key_value",
    "body": [
      "enum ${1:EnumName} {",
      "\t${2:Up} = ${3:1},",
      "\t${4:Down} = ${5:2}",
      "}"
    ],
    "description": "Declare an enum in TypeScript"
  },
  "enum:create:with string members": {
    "prefix": "enum_with_member_string",
    "body": [
      "enum ${1:EnumName} {",
      "\t${2:Info} = '${3:INFO}',",
      "\t${4:Warn} = '${5:WARN}',",
      "\t${6:Error} = '${7:ERROR}'",
      "}"
    ],
    "description": "Create an enum with string members"
  },
  "region:start": {
    "prefix": "region_start",
    "body": ["//#region $0"],
    "description": "//#region $0"
  },
  "region:end": {
    "prefix": "region_end",
    "body": ["//#endregion"],
    "description": "//#endregion"
  },
  "console:log": {
    "prefix": "log_",
    "body": "console.log(${0})",
    "description": "console.log()"
  },
  "console:dir": {
    "prefix": "log_dir",
    "body": "console.dir('${1}:', ${1})",
    "description": "console.dir('x', y)"
  },
  "console:error": {
    "prefix": "log_err",
    "body": "console.error(${0})",
    "description": "console.error()"
  },
  "console:warn": {
    "prefix": "log_warn_",
    "body": ["console.warn($1);", "$0"],
    "description": "console.warn();"
  },
  "type definition": {
    "prefix": "type_",
    "body": ["type ${1:name} = {", "\t$0", "}"],
    "description": "Type Definition"
  },
  "interface:create": {
    "prefix": "interface_",
    "body": ["interface ${1:name} {", "\t$0", "}"],
    "description": "Interface Definition"
  },
  "interface:export named": {
    "prefix": "interface_export",
    "body": ["export interface ${1:InterfaceName} {", "\t$0", "}"],
    "description": "Export named interface in TypeScript"
  },
  "interface:export default interface declaration": {
    "prefix": "interface_export_default",
    "body": ["export default interface ${1:InterfaceName} {", "\t$0", "}"],
    "description": "Export default interface in TypeScript"
  },
  "interface:prop:readonly": {
    "prefix": "interface_prop_readonly",
    "body": ["readonly ${1:propertyName}: ${2:type};"],
    "description": "Define a readonly property in an interface"
  },
  "interface:prop:optional property": {
    "prefix": "interface_prop_optional",
    "body": ["${1:propertyName}?: ${2:type};"],
    "description": "Define an optional property in an interface"
  },
  "interface:prop:with default value": {
    "prefix": "interface_prop_with_default",
    "body": ["${1:propertyName} = ${2:defaultValue};"],
    "description": "Define a property with a default value in an interface (note: default values are not applicable to interfaces, typically used for classes)"
  },
  "interface:prop:index signature": {
    "prefix": "interface_prop_index_signature",
    "body": ["[${1:key}: ${2:keyType}]: ${3:valueType};"],
    "description": "Define an index signature property in an interface"
  },
  "interface:prop:nested object": {
    "prefix": "interface_prop_nested_object",
    "body": [
      "${1:propertyName}: {",
      "  ${2:nestedProperty1}: ${3:type1};",
      "  ${4:nestedProperty2}?: ${5:type2};",
      "};"
    ],
    "description": "Define a property that is a nested object in an interface"
  },
  "interface:prop:union type": {
    "prefix": "interface_prop_union_type",
    "body": ["${1:propertyName}: ${2:type1} | ${3:type2};"],
    "description": "Define a property with a union type in an interface"
  },
  "interface:prop:intersection type": {
    "prefix": "interface_prop_intersection_type",
    "body": ["${1:propertyName}: ${2:type1} & ${3:type2};"],
    "description": "Define a property with an intersection type in an interface"
  },
  "interface:prop:generic property": {
    "prefix": "interface_prop_generic_property",
    "body": ["${1:propertyName}: ${2<T>};"],
    "description": "Define a property with a generic type in an interface"
  },
  "interface:prop:type array property": {
    "prefix": "interface_prop_array_property",
    "body": ["${1:propertyName}: ${2:type}[];"],
    "description": "Define a property that is an array in an interface"
  },
  "interface:prop:tuple type": {
    "prefix": "interface_prop_tuple",
    "body": ["${1:propertyName}: [${2:type1}, ${3:type2}];"],
    "description": "Define a property that is a tuple in an interface"
  },
  "interface:prop:function type property": {
    "prefix": "interface_prop_function_property",
    "body": [
      "${1:propertyName}: (${2:param1}: ${3:type1}, ${4:param2}: ${5:type2}) => ${6:returnType};"
    ],
    "description": "Define a property that is a function in an interface"
  },
  "interface:prop:reacord utility type": {
    "prefix": "interface_prop_record_type_utility",
    "body": ["${1:propertyName}: Record<${2:keyType}, ${3:valueType}>;"],
    "description": "Define a property that uses the Record utility type in an interface"
  },
  "interface:prop:partial utility type": {
    "prefix": "interface_prop_partial_type_utility",
    "body": ["${1:propertyName}: Partial<${2:Type}>;"],
    "description": "Define a property that uses the Partial utility type in an interface"
  },
  "interface:prop:pick utility type": {
    "prefix": "interface_prop_pick_type_utility",
    "body": ["${1:propertyName}: Pick<${2:Type}, ${3:key1 | key2}>;"],
    "description": "Define a property that uses the Pick utility type in an interface"
  },
  "interface:prop:omit utility type": {
    "prefix": "interface_prop_omit_type_utility",
    "body": ["${1:propertyName}: Omit<${2:Type}, ${3:key1 | key2}>;"],
    "description": "Define a property that uses the Omit utility type in an interface"
  },
  "interface:prop:exclude utility type": {
    "prefix": "interface_prop_exclude_type_utility",
    "body": ["${1:propertyName}: Exclude<${2:type1}, ${3:type2}>;"],
    "description": "Define a property that uses the Exclude utility type in an interface"
  },
  "interface:prop:extract utility type": {
    "prefix": "interface_prop_extract_type_utility",
    "body": ["${1:propertyName}: Extract<${2:type1}, ${3:type2}>;"],
    "description": "Define a property that uses the Extract utility type in an interface"
  },
  "interface:prop:nonnullable utility type": {
    "prefix": "interface_prop_nonnullable_type_utility",
    "body": ["${1:propertyName}: NonNullable<${2:type}>;"],
    "description": "Define a property that uses the NonNullable utility type in an interface"
  },
  "interface:prop:returntype utility type": {
    "prefix": "interface_prop_returntype_type_utility",
    "body": ["${1:propertyName}: ReturnType<${2:functionType}>;"],
    "description": "Define a property that uses the ReturnType utility type in an interface"
  },
  "instance:prop:instancetype utility type": {
    "prefix": "interface_prop_instancetype_type_utility",
    "body": ["${1:propertyName}: InstanceType<${2:classType}>;"],
    "description": "Define a property that uses the InstanceType utility type in an interface"
  },
  "triple-slash reference": {
    "prefix": "ref_",
    "body": ["/// <reference path=\"$1\" />", "$0"],
    "description": "Triple-slash reference"
  },
  "class:create": {
    "prefix": "class_",
    "body": [
      "class ${1:name} {",
      "\tconstructor(${2:parameters}) {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Class Definition"
  },
  "class:t:with inheritance": {
    "prefix": "class_t_inherit_class",
    "body": ["class ${1:ChildClass} extends ${2:ParentClass} {"],
    "description": "Create class with inheritance"
  },
  "class:t:with inheritance multi": {
    "prefix": "class_t_inherit_class_multi",
    "body": [
      "class ${1:ChildClass} extends ${2:Mixin1}(${3:Mixin2}(${4:BaseClass})) {"
    ],
    "description": "Create class with multiple inheritance"
  },
  "class:t:with inheritance interface": {
    "prefix": "class_t_inherit_interface",
    "body": ["class ${1:ClassName} implements ${2:InterfaceName} {"],
    "description": "Class with interface implementation"
  },
  "class:t:with inheritance interface multi": {
    "prefix": "class_t_interit_interface_multi",
    "body": [
      "class ${1:ClassName} implements ${2:Interface1}, ${3:Interface2} {"
    ],
    "description": "Class with multiple interface implementation"
  },
  "class:t:with inheritance interface generic": {
    "prefix": "class_t_inherit_interface_generic",
    "body": ["class ${1:ClassName} implements ${2:InterfaceName}<${3:T}> {"],
    "description": "Class with generic interface implementation"
  },
  "class:t:with inheritance class and implements interface": {
    "prefix": "class_t_inherit_and_implements_class_interface",
    "body": [
      "class ${1:ChildClass} extends ${2:ParentClass} implements ${3:InterfaceName} {"
    ],
    "description": "Class with extend and interface implementation"
  },
  "class:t:with inheritance error": {
    "prefix": "class_t_inherit_custom_err",
    "body": ["class ${1:CustomError} extends Error {"],
    "description": "Create a custom error class"
  },
  "class:property": {
    "prefix": "class_prop_",
    "body": [
      "${1:private_or_public} ${2:propertyName}: ${3:type} = ${4:value};"
    ],
    "description": "Define a full property"
  },
  "class:property:private": {
    "prefix": "class_prop_private",
    "body": ["private ${1:propertyName}: ${2:type};", "$0"],
    "description": "Declare a private property in a class in TypeScript"
  },
  "class:property:protected": {
    "prefix": "class_prop_protected",
    "body": ["protected ${1:propertyName}: ${2:type};", "$0"],
    "description": "Declare a protected property in a class in TypeScript"
  },
  "class:property:readonly": {
    "prefix": "class_prop_readonly",
    "body": ["readonly ${1:propertyName}: ${2:type};", "$0"],
    "description": "Declare a readonly property in TypeScript"
  },
  "class:property:full with get and set func": {
    "prefix": "class_prop_get_set_full",
    "body": [
      "",
      "private _${1:value} : ${2:string};",
      "public get ${1:value}() : ${2:string} {",
      "\treturn this._${1:value};",
      "}",
      "public set ${1:value}(v : ${2:string}) {",
      "\tthis._${1:value} = v;",
      "}",
      ""
    ],
    "description": "Define a full property"
  },
  "class:constructor:with parameters": {
    "prefix": "class_constructor_param",
    "body": [
      "constructor(${1:params}) {",
      "    this.${1:params} = ${1:params};",
      "}"
    ],
    "description": "Constructor with parameters"
  },
  "class:constructor:with parameter empty": {
    "prefix": "class_constructor_param_empty",
    "body": ["constructor() {", "\t${0:// Write your code here}", "}"],
    "description": "Empty constructor"
  },
  "class:constructor:with object destructuring": {
    "prefix": "class_constructor_param_destructuring",
    "body": [
      "constructor({${1:prop1}, ${2:prop2}}) {",
      "    this.${1:prop1} = ${1:prop1};",
      "    this.${2:prop2} = ${2:prop2};",
      "}"
    ],
    "description": "Constructor with object destructuring"
  },
  "class:constructor:with optional parameter": {
    "prefix": "class_constructor_param_optional",
    "body": [
      "constructor(${1:params}?: ${2:type}) {",
      "    this.${1:params} = ${1:params} ?? ${3:defaultValue};",
      "}"
    ],
    "description": "Constructor with optional parameter"
  },
  "class:constructor:with rest parameter": {
    "prefix": "class_constructor_param_rest",
    "body": [
      "constructor(...${1:params}) {",
      "    this.${1:params} = ${1:params};",
      "}"
    ],
    "description": "Constructor with rest parameter"
  },
  "class:constructor:with object initialization": {
    "prefix": "class_constructor_param_obj_init",
    "body": ["constructor(obj: any) {", "\tObject.assign(this, obj);", "}"],
    "description": "Constructor with object initialization"
  },
  "class:constructor:with optional parameter and default value": {
    "prefix": "class_constructor_param_optional_and_default",
    "body": [
      "constructor(${1:params}: ${2:type} = ${3:defaultValue}) {",
      "    this.${1:params} = ${1:params};",
      "}"
    ],
    "description": "Constructor with optional parameter and default value"
  },
  "class:constructor:with readonly parameter": {
    "prefix": "class_constructor_param_readonly",
    "body": ["constructor(readonly ${1:params}: ${2:type}) {", "}"],
    "description": "Constructor with readonly parameter"
  },
  "class:t:constructor:parameter": {
    "prefix": "class_t_constructor_param_single",
    "body": ["constructor(${1:param}: ${2:type}) {", "}"],
    "description": "Constructor with single parameter"
  },
  "class:t:constructor:with multiple parameters": {
    "prefix": "class_t_constructor_param_multi",
    "body": ["constructor(${1:param1}: ${2:type1}, ${3:param2}: ${4:type2}) {"],
    "description": "Constructor with multiple parameters"
  },
  "class:t:constructor:empty": {
    "prefix": "class_t_constructor_empty",
    "body": ["constructor() {", "\t$0", "}"],
    "description": "Default constructor"
  },
  "class:t:constructor:with default values": {
    "prefix": "class_t_constructor_param_default",
    "body": [
      "constructor(${1:param1}: ${2:type1} = ${3:default1}, ${4:param2}: ${5:type2} = ${6:default2}) {"
    ],
    "description": "Constructor with default values"
  },
  "class:t:constructor:overload": {
    "prefix": "class_t_constructor_overload",
    "body": [
      "constructor();",
      "constructor(${1:param}: ${2:type});",
      "constructor(${1:param1}: ${2:type1}, ${3:param2}: ${4:type2});",
      "constructor(${1:param1}: ${2:type1} = ${3:default1}, ${4:param2}: ${5:type2} = ${6:default2}) {",
      "\tif (arguments.length === 0) {",
      "\t\t// Default constructor logic",
      "\t} else if (arguments.length === 1) {",
      "\t\t// Constructor with single parameter logic",
      "\t\tthis.${1:param} = ${1:param};",
      "\t} else if (arguments.length === 2) {",
      "\t\t// Constructor with two parameters logic",
      "\t\tthis.${1:param1} = ${1:param1};",
      "\t\tthis.${3:param2} = ${3:param2};",
      "\t}",
      "$0",
      "}"
    ],
    "description": "Constructor overload"
  },
  "class:t:constructor with property initialization": {
    "prefix": "class_t_constructor_prop_init",
    "body": [
      "constructor(public ${1:param1}: ${2:type1}, private ${3:param2}: ${4:type2}) {"
    ],
    "description": "Constructor with property initialization"
  },
  "class:t:constructor with readonly parameter": {
    "prefix": "class_t_constructor_param_readonly",
    "body": ["constructor(readonly ${1:param}: ${2:type}) {", "\t$0", "}"],
    "description": "Constructor with readonly parameter"
  },
  "class:t:constructor with optional parameter": {
    "prefix": "class_t_constructor_param_optional",
    "body": [
      "constructor(${1:param1}: ${2:type1}, ${3:param2}?: ${4:type2}) {",
      "\tthis.${1:param1} = ${1:param1};",
      "\tif (${3:param2} !== undefined) {",
      "\t\tthis.${3:param2} = ${3:param2};",
      "\t}",
      "$0",
      "}"
    ],
    "description": "Constructor with optional parameter"
  },
  "class:t:constructor with rest parameter": {
    "prefix": "class_t_constructor_param_rest",
    "body": ["constructor(...${1:params}: ${2:type}[]) {"],
    "description": "Constructor with rest parameter"
  },
  "class:t:constructor with object destructuring": {
    "prefix": "class_t_constructor_destructuring",
    "body": [
      "constructor({ ${1:param1}, ${2:param2} }: { ${1:param1}: ${3:type1}, ${2:param2}: ${4:type2} }) {"
    ],
    "description": "Constructor with object destructuring"
  },
  "class:t:constructor with optional parameter and default value": {
    "prefix": "class_t_constructor_param_optional_init",
    "body": [
      "constructor(${1:param1}: ${2:type1}, ${3:param2}?: ${4:type2} = ${5:defaultValue}) {"
    ],
    "description": "Constructor with optional parameter and default value"
  },
  "class:t:constructor with optional readonly parameter": {
    "prefix": "class_t_constructor_param_readonly_optional",
    "body": [
      "constructor(readonly ${1:param1}: ${2:type1}, ${3:param2}?: ${4:type2}) {"
    ],
    "description": "Constructor with optional readonly parameter"
  },
  "class:t:constructor with optional property initialization": {
    "prefix": "class_t_constructor_prop_init_optional",
    "body": [
      "constructor(public ${1:param1}: ${2:type1}, private ${3:param2}?: ${4:type2}) {"
    ],
    "description": "Constructor with optional property initialization"
  },
  "class:constructor:prop:init": {
    "prefix": "class_constructor_prop",
    "body": ["this.${1:propertyName} = ${2:value};"],
    "description": "Constructor with property initialization"
  },
  "class:constructor:prop:super call": {
    "prefix": "class_constructor_prop_super_call",
    "body": [
      "constructor(${1:params}) {",
      "    super();",
      "    this.${1:params} = ${1:params};",
      "}"
    ],
    "description": "Constructor with super call"
  },
  "class:method:func": {
    "prefix": "class_method",
    "body": ["/**", " * ${1:name}", " */", "${1:name}() {", "\t$0", "}"],
    "description": "Public Method Definition"
  },
  "class:method:public getter": {
    "prefix": "class_method_getter_public",
    "body": [
      "",
      "public get ${1:value}() : ${2:string} {",
      "\t${3:return $0}",
      "}",
      ""
    ],
    "description": "Property getter"
  },
  "class:method:public setter": {
    "prefix": "class_method_setter_public",
    "body": [
      "",
      "public set ${1:value}(v : ${2:string}) {",
      "\tthis.$3 = v;",
      "}",
      ""
    ],
    "description": "Property setter"
  },
  "class:method:getter": {
    "prefix": "class_method_getter",
    "body": "get ${1:property} () {\n\t${0}\n}",
    "description": "get property () {\n\n}"
  },
  "class:method:setter": {
    "prefix": "class_method_settter",
    "body": "set ${1:property} (${2:value}) {\n\t${0}\n}",
    "description": "set property (value) {\n\n}"
  },
  "class:method:getter plus with setter": {
    "prefix": "class_method_setter_and_getter",
    "body": "get ${1:property} () {\n\t${0}\n}\nset ${1:property} (${2:value}) {\n\t\n}",
    "description": "get property () {\n\n}\nset ${1:property} (value) {\n\t\n}"
  },
  "class:method:func private": {
    "prefix": "class_method_private",
    "body": ["private ${1:name}() {", "\t$0", "}"],
    "description": "Private Method Definition"
  },
  "class:inherit:class": {
    "prefix": "class_inherit_class",
    "body": [
      "export class ${1:ChildClass} extends ${2:ParentClass} {",
      "\tconstructor() {",
      "\t\tsuper(); // Call the parent constructor",
      "\t}",
      "}"
    ],
    "description": "Creates a class that inherits from another class"
  },
  "class:inherit:abstract class": {
    "prefix": "class_inherit_abstract_class",
    "body": [
      "export class ${1:ChildClass} extends ${2:AbstractClass} {",
      "\tconstructor() {",
      "\t\tsuper(); // Call the parent constructor",
      "\t}",
      "\toverrideMethod() {",
      "\t\t// Method implementation",
      "\t}",
      "}"
    ],
    "description": "Creates a class that inherits from an abstract class"
  },
  "class:inherit:interface": {
    "prefix": "class_inherit_interface",
    "body": [
      "interface ${1:InterfaceName} {",
      "\tmethod1(): void;",
      "\tmethod2(): number;",
      "}",
      "",
      "export class ${2:ClassName} implements ${1:InterfaceName} {",
      "\tmethod1() {",
      "\t\t// Method implementation",
      "\t}",
      "",
      "\tmethod2() {",
      "\t\treturn 0; // Method implementation",
      "\t}",
      "}"
    ],
    "description": "Creates a class that implements an interface"
  },
  "abstract:create": {
    "prefix": "abstract_",
    "body": [
      "abstract class ${1:ClassName} {",
      "\tabstract ${2:methodName}(${3:params}): ${4:void};",
      "",
      "\t${5:constructor()}",
      "",
      "\t${6:// properties}",
      "\tabstract ${7:propertyName}: ${8:type};",
      "",
      "\t${9:// methods}",
      "}"
    ],
    "description": "Create an abstract class"
  },
  "abstract:create 2": {
    "prefix": "abstract_2",
    "body": [
      "abstract class ${1:ClassName} {",
      "\tconstructor(${2:params}) {",
      "\t\t${3:// initialization}",
      "\t}",
      "",
      "\tabstract ${4:methodName}(${5:params}): ${6:void};",
      "",
      "\tabstract ${7:propertyName}: ${8:type};",
      "",
      "\t${9:// additional methods or properties}",
      "}"
    ],
    "description": "Create an abstract class with a constructor"
  },
  "abstract:create with methods and properties": {
    "prefix": "abstract_2_with_methods_and_properties",
    "body": [
      "abstract class ${1:ClassName} {",
      "\t// Properties",
      "\tabstract ${2:propertyName}: ${3:type};",
      "",
      "\t// Constructor",
      "\tconstructor(${4:params}) {",
      "\t\t${5:// initialization}",
      "\t}",
      "",
      "\t// Methods",
      "\tabstract ${6:methodName}(${7:params}): ${8:void};",
      "",
      "\t// Optional: Add more methods",
      "\t${9:// additional methods}",
      "}"
    ],
    "description": "Create an abstract class with properties and methods"
  },
  "abstract:method": {
    "prefix": "abstract_method",
    "body": ["abstract ${1:methodName}(${2:params}): ${3:void};"],
    "description": "Create an abstract method"
  },
  "abstract:method:with default parameter": {
    "prefix": "abstract_method_with_default_parameter",
    "body": [
      "abstract ${1:methodName}(${2:paramName} = ${3:defaultValue}): ${4:void};"
    ],
    "description": "Create an abstract method with a default parameter"
  },
  "abstract:method:with different method visibilities": {
    "prefix": "abstract_method_with_different_visibilities",
    "body": [
      "\tpublic abstract publicMethod(): void;",
      "\tprotected abstract protectedMethod(): void;",
      "\tprivate abstract privateMethod(): void;",
      "",
      "\tabstract abstractMethod(): void;"
    ],
    "description": "Creates an abstract class with methods of different visibilities"
  },
  "abstract:method:with getter and setter": {
    "prefix": "abstract_method_with_getter_and_setter",
    "body": [
      "export abstract class ${1:AbstractClass} {",
      "\tprivate _prop: string = '';",
      "",
      "\tget prop(): string {",
      "\t\treturn this._prop;",
      "\t}",
      "",
      "\tset prop(value: string) {",
      "\t\tthis._prop = value;",
      "\t}",
      "",
      "\tabstract abstractMethod(): void;",
      "}"
    ],
    "description": "Creates an abstract class with a getter and setter"
  },
  "abstract:prop:with access modifier": {
    "prefix": "abstract_prop_access_modifier",
    "body": ["${1:accessModifier} abstract ${2:propertyName}: ${3:type};"],
    "description": "Create an abstract property with an access modifier (e.g., public, protected)"
  },
  "abstract:prop:with default value": {
    "prefix": "abstract_prop_access_modifier",
    "body": ["abstract ${1:propertyName}: ${2:type} = ${3:defaultValue};"],
    "description": "Create an abstract property with a default value (note: default value is usually not applicable for abstract properties)"
  },
  "abstract:constructor": {
    "prefix": "abstract_constructor",
    "body": [
      "\tconstructor() {",
      "\t\t// Constructor logic here",
      "\t}",
      "\tabstract abstractMethod(): void;",
      "}"
    ],
    "description": "Creates an abstract class with a constructor"
  },
  "abstract:constructor:with parameter": {
    "prefix": "abstract_constructor_with_parameter",
    "body": [
      "\tconstructor(private param1: string, protected param2: number) {",
      "\t\t// Constructor logic here",
      "\t}",
      "",
      "\tabstract abstractMethod(): void;",
      "}"
    ],
    "description": "Creates an abstract class with a constructor and parameters"
  }
}
