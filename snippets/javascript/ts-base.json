{
  "TODO": {
    "prefix": "todo_",
    "body": ["// TODO: $0"],
    "description": "// TODO: ..."
  },
  "use strict": {
    "prefix": "use_strict",
    "body": "'use strict'",
    "description": "use strict"
  },
  "require": {
    "prefix": "req_",
    "body": "require('${1:module}')",
    "description": "require(\"module\")"
  },
  "export:named declaration": {
    "prefix": "export_",
    "body": ["export { ${1:exportedName} };", "$0"],
    "description": "Declare a named export in TypeScript"
  },
  "export:member": {
    "prefix": "exports_member",
    "body": "exports.${1:member} = ${2:value}",
    "description": "exports.member = value"
  },
  "export:default:declaration": {
    "prefix": "export_default",
    "body": ["export default ${1:expression};", "$0"],
    "description": "Declare a default export in TypeScript"
  },
  "module:exports": {
    "prefix": "module_exports",
    "body": "module.exports = ${1:name}",
    "description": "module.exports = name"
  },
  "module:ambient:declaration": {
    "prefix": "module_ambient",
    "body": ["declare module '${1:moduleName}' {", "\t$0", "}"],

    "description": "Declare an ambient module in TypeScript"
  },
  "namespace:declaration": {
    "prefix": "namespace_",
    "body": ["namespace ${1:NamespaceName} {", "\t$0", "}"],
    "description": "Declare a namespace in TypeScript"
  },
  "namespace:module export": {
    "prefix": "namespace_export",
    "body": ["export namespace ${1:NamespaceName} {", "\t$0", "}"],
    "description": "Export a namespace module in TypeScript"
  },
  "import module destructured": {
    "prefix": "imp_from",
    "body": "import {$2} from '${1:module}'",
    "description": "import value from 'module'"
  },
  "import module as": {
    "prefix": "imp_from_as",
    "body": "import ${2:*} as ${3:name} from '${1:module}'",
    "description": "import * as name from 'module'"
  },
  "import statement": {
    "prefix": "imp_",
    "body": ["import { ${1:importedName} } from '${2:module}';", "$0"],
    "description": "Import statement in TypeScript"
  },
  "Import Default Statement": {
    "prefix": "imp_default",
    "body": ["import ${1:defaultName} from '${2:module}';", "$0"],
    "description": "Import default statement in TypeScript"
  },
  "import all statement": {
    "prefix": "imp_all",
    "body": ["import * as ${1:namespace} from '${2:module}';", "$0"],
    "description": "Import all statement in TypeScript"
  },
  "const:statement": {
    "prefix": "const_",
    "body": "const ${1:name} = ${0}",
    "description": "const name"
  },
  "const:array": {
    "prefix": "const_array",
    "body": ["const ${1:arrayName}: ${2:Type}[] = [${3}]$0;"]
  },
  "const:array emtpy": {
    "prefix": "const_array_empty",
    "body": ["const ${1:arrayName}: ${2:Type}[] = [];", "$0"],
    "description": "Declare an empty array in TypeScript"
  },
  "const:object": {
    "prefix": "const_obj",
    "body": [
      "const ${1:objName}: { ${2:key}: ${3:Type} } = { ${2:key}: ${4:value} }$0;"
    ],
    "description": "Declare an object in TypeScript"
  },
  "const:object empty": {
    "prefix": "const_obj_empty",
    "body": ["const ${1:objName}: { ${2:key}: ${3:Type} } = {};", "$0"],
    "description": "Declare an empty object in TypeScript"
  },
  "const:map": {
    "prefix": "const_map",
    "body": [
      "const ${1:mapName}: Map<${2:KeyType}, ${3:ValueType}> = new Map();$0"
    ],
    "description": "Declare a Map in TypeScript"
  },
  "const:map empty": {
    "prefix": "const_map_empty",
    "body": [
      "const ${1:mapName}: Map<${2:KeyType}, ${3:ValueType}> = new Map();",
      "$0"
    ],
    "description": "Declare an empty Map in TypeScript"
  },
  "const:set": {
    "prefix": "const_set",
    "body": ["const ${1:setName}: Set<${2:Type}> = new Set([${3}]);$0"],
    "description": "Declare a Set in TypeScript"
  },
  "const:set empty": {
    "prefix": "const_set_empty",
    "body": ["const ${1:setName}: Set<${2:Type}> = new Set();", "$0"],
    "description": "Declare an empty Set in TypeScript"
  },
  "const:tuple": {
    "prefix": "const_tuple",
    "body": [
      "let ${1:tupleName}: [${2:Type1}, ${3:Type2}] = [${4:value1}, ${5:value2}];$0"
    ],
    "description": "Declare a tuple in TypeScript"
  },
  "const:destructuring:statement": {
    "prefix": "const_destructuring",
    "body": "const { ${2:prop} } = ${1:value}",
    "description": "const { prop } = value"
  },
  "const:destructuring:statement from array": {
    "prefix": "const_array_d",
    "body": "const [ ${2:prop} ] = ${1:value}",
    "description": "const [ prop ] = value"
  },
  "const:destructuring:statement awaited": {
    "prefix": "cosnt_a_d",
    "body": "const { ${1:name} } = await ${2:value}",
    "description": "const { name } = await value"
  },
  "const:promise declaration": {
    "prefix": "const_new_promise",
    "body": [
      "const ${1:promiseName}: Promise<${2:Type}> = new Promise((resolve, reject) => {",
      "\t// Resolve or reject logic",
      "\tresolve(${3:value});",
      "});",
      "$0"
    ],
    "description": "Declare a Promise in TypeScript"
  },
  "const:date object declaration": {
    "prefix": "const_date",
    "body": ["const ${1:dateName}: Date = new Date();", "$0"],
    "description": "Declare a Date object in TypeScript"
  },
  "const:regexp object declaration": {
    "prefix": "const_regexp",
    "body": ["const ${1:regexName}: RegExp = /${2:pattern}/;", "$0"],
    "description": "Declare a RegExp object in TypeScript"
  },
  "const:template literal": {
    "prefix": "const_string_template",
    "body": ["const ${1:variable}: string = `${2:expression}`;", "$0"],
    "description": "Declare a template literal in TypeScript"
  },
  "const:obj class": {
    "prefix": "const_new_obj",
    "body": ["const ${1:name} = new ${2:type}(${3:arguments});$0"],
    "description": "const name = new type(arguments);"
  },
  "const:assignment awaited": {
    "prefix": "const_await",
    "body": "const ${1:name} = await ${2:value}",
    "description": "const name = await value"
  },
  "const:assignment yielded": {
    "prefix": "const_yield",
    "body": "const ${1:name} = yield ${2:value}",
    "description": "const name = yield value"
  },
  "const:module = require('module')": {
    "prefix": "const_require",
    "body": "const ${1:module} = require('${1:module}')",
    "description": "const module = require('module')"
  },
  "const:module export": {
    "prefix": "const_export",
    "body": "export const ${1:member} = ${2:value}",
    "description": "export const member = value"
  },
  "chaining:optional chaining": {
    "prefix": "chaining_optional",
    "body": ["${1:object}.${2:property}?.${3:subproperty};", "$0"],
    "description": "Use optional chaining operator in TypeScript"
  },
  "chaining:nullish coalescing operator": {
    "prefix": "chaining_nullish",
    "body": ["${1:variable} ?? ${2:defaultValue};", "$0"],
    "description": "Use nullish coalescing operator in TypeScript"
  },
  "const:spread operator (array)": {
    "prefix": "const_spread_array",
    "body": [
      "const ${1:arrayName}: ${2:Type}[] = [...${3:sourceArray}];",
      "$0"
    ],
    "description": "Use spread operator for arrays in TypeScript"
  },
  "const:spread operator (object)": {
    "prefix": "const_spread_object",
    "body": [
      "const ${1:objName}: { ...${2:sourceObject} } = { ...${2:sourceObject} };",
      "$0"
    ],
    "description": "Use spread operator for objects in TypeScript"
  },
  "const:array:destructuring": {
    "prefix": "const_array_destructuring",
    "body": ["const [${1:elem1}, ${2:elem2}] = ${3:sourceArray};", "$0"],
    "description": "Destructuring assignment for arrays in TypeScript"
  },
  "const:object:destructuring": {
    "prefix": "const_object_destructuring",
    "body": ["const { ${1:key1}, ${2:key2} } = ${3:sourceObject};", "$0"],
    "description": "Destructuring assignment for objects in TypeScript"
  },
  "var:global variable declaration": {
    "prefix": "var_global",
    "body": [
      "declare global {",
      "\tvar ${1:globalVariable}: ${2:Type};",
      "}",
      "$0"
    ],
    "description": "Declare a global variable in TypeScript"
  },
  "let:statement": {
    "prefix": "let_",
    "body": "let ${1:name} = $0",
    "description": "let name"
  },
  "let:assignment awaited": {
    "prefix": "let_await",
    "body": "let ${1:name} = await ${2:value}",
    "description": "let name = await value"
  },
  "let:assignment yielded": {
    "prefix": "let_yield",
    "body": "let ${1:name} = yield ${2:value}",
    "description": "let name = yield value"
  },
  "generate array of integers starting with 1": {
    "prefix": "gari",
    "body": "Array.from({ length: ${1:length} }, (v, k) => k + 1)",
    "description": "Array.from({ length: xlength} }, (v, k) => k + 1)"
  },
  "generate array of integers starting with 0": {
    "prefix": "gari0",
    "body": "[...Array(${1:length}).keys()]",
    "description": "[...Array(length).keys()]"
  },
  "typeof": {
    "prefix": "typeof_",
    "body": "typeof ${1:source} === '${2:undefined}'",
    "description": "typeof source === 'undefined'"
  },
  "instanceof": {
    "prefix": "instanceof_",
    "body": "${1:source} instanceof ${2:Object}",
    "description": "value instanceof Myclass"
  },
  "prototype method": {
    "prefix": "prototype_",
    "body": "${1:Class}.prototype.${2:method} = function (${3:arguments}) {\n\t${0}\n}",
    "description": "Class.prototype.method = function (arguments) {\n\n}"
  },
  "ternary": {
    "prefix": "tern_",
    "body": "${1:cond} ? ${2:true} : ${3:false}",
    "description": "cond ? true : false"
  },
  "ternary var assignment": {
    "prefix": "var_tern",
    "body": "var ${0} = ${1:cond} ? ${2:true} : ${3:false}",
    "description": "var ${0} = ${1:cond} ? ${2:true} : ${3:false}"
  },
  "ternary const assignment": {
    "prefix": "const_tern",
    "body": "const ${0} = ${1:cond} ? ${2:true} : ${3:false}",
    "description": "const ${0} = ${1:cond} ? ${2:true} : ${3:false}"
  },
  "return arrow function": {
    "prefix": "rt_arr_",
    "body": "return (${1:arguments}) => ${2:statement}",
    "description": "return (arguments) => statement"
  },
  "return this": {
    "prefix": "rt_this",
    "body": "return ${0:this}",
    "description": "return this"
  },
  "return null": {
    "prefix": "rt_null",
    "body": "return null",
    "description": "return null"
  },
  "return new array": {
    "prefix": "rt_array",
    "body": "return [\n\t${0}\n]",
    "description": "return [\n\n]"
  },
  "define module": {
    "prefix": "define_",
    "body": [
      "define([",
      "\t'require',",
      "\t'${1:dependency}'",
      "], function(require, ${2:factory}) {",
      "\t'use strict';",
      "\t$0",
      "});"
    ],
    "description": [
      "define([",
      "\t'require',",
      "\t'${1:dependency}'",
      "], function(require, ${2:factory}) {",
      "\t'use strict';",
      "\t$0",
      "});"
    ]
  },
  "for": {
    "prefix": "for_",
    "body": [
      "for (let ${1:index} = 0; ${1:index} < ${2:array}.length; ${1:index}++) {",
      "\tconst ${3:element} = ${2:array}[${1:index}];",
      "\t$0",
      "}"
    ],
    "description": [
      "for (let index = 0; index < array.length; index++) {",
      "\tconst element = array\\[index\\];",
      "\t$0",
      "}"
    ]
  },
  "for:each": {
    "prefix": "for_each",
    "body": ["${1:array}.forEach(${2:element} => {", "\t$0", "});"],
    "description": ["array.forEach(element => {", "", "});"]
  },
  "for:in": {
    "prefix": "for_in",
    "body": [
      "for (const ${1:key} in ${2:object}) {",
      "\tif (${2:object}.hasOwnProperty(${1:key})) {",
      "\t\tconst ${3:element} = ${2:object}[${1:key}];",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": [
      "for (const key in object) {",
      "\tif (object.hasOwnProperty(key)) {",
      "\t\tconst element = object\\[key\\];",
      "",
      "\t}",
      "}"
    ]
  },
  "for:of": {
    "prefix": "for_of",
    "body": ["for (const ${1:iterator} of ${2:myarray}) {", "\t$0", "}"],
    "description": ["for (const iterator of array) {", "", "}"]
  },
  "for:await-of loop": {
    "prefix": "for_of_await",
    "body": [
      "for await (const ${1:iterator} of ${2:object}) {",
      "\t$TM_SELECTED_TEXT$0",
      "}"
    ],
    "description": "For-Await-Of Loop"
  },
  "for:map": {
    "prefix": "for_map",
    "body": "${1:iterable}.map((${2:item}) => {\n\t${0}\n})",
    "description": "iterable.map((item) => {\n\n})"
  },
  "for:reduce": {
    "prefix": "for_reduce",
    "body": "${1:iterable}.reduce((${2:previous}, ${3:current}) => {\n\t${0}\n}${4:, initial})",
    "description": "iterable.reduce((previous, current) => {\n\n}, initial)"
  },
  "for:filter": {
    "prefix": "for_filter",
    "body": "${1:iterable}.filter((${2:item}) => {\n\t${0}\n})",
    "description": "iterable.filter((item) => {\n\n})"
  },
  "for:find": {
    "prefix": "for_find",
    "body": "${1:iterable}.find((${2:item}) => {\n\t${0}\n})",
    "description": "iterable.find((item) => {\n\n})"
  },
  "for:every": {
    "prefix": "for_every",
    "body": "${1:iterable}.every((${2:item}) => {\n\t${0}\n})",
    "description": "iterable.every((item) => {\n\n})"
  },
  "for:some": {
    "prefix": "for_some",
    "body": "${1:iterable}.some((${2:item}) => {\n\t${0}\n})",
    "description": "iterable.some((item) => {\n\n})"
  },
  "function": {
    "prefix": "func_",
    "body": ["function ${1:name}(${2:params}) {", "\t$0", "}"],
    "description": ["function name(params) {", "", "}"]
  },
  "function:anonymous": {
    "prefix": "func_anon",
    "body": "function (${1:arguments}) {${0}}",
    "description": "function (arguments) {value}"
  },
  "function:callback": {
    "prefix": "func_callback",
    "body": "function (err, ${1:value}) {\n\tif (err) throw err\n\t${0}\n}",
    "description": "function (err, value) {\n\tif (err) throw err\n\n}"
  },
  "function:export named": {
    "prefix": "func_export",
    "body": "export function ${1:member} (${2:arguments}) {\n\t${0}\n}",
    "description": "export function member (arguments) {\n\n}"
  },
  "function:param:optional": {
    "prefix": "function_param_optional",
    "body": [
      "function ${1:functionName}(${2:param1}: ${3:Type} = ${4:defaultValue}) {",
      "\t$0",
      "}"
    ],
    "description": "Declare a function with optional parameters in TypeScript"
  },
  "function:param:rest": {
    "prefix": "function_param_rest",
    "body": [
      "function ${1:functionName}(...${2:params}: ${3:Type}[]) {",
      "\t$0",
      "}"
    ],
    "description": "Declare a function with rest parameters in TypeScript"
  },
  "function:param:default": {
    "prefix": "function_param_default",
    "body": [
      "function ${1:functionName}(${2:param1}: ${3:Type} = ${4:defaultValue}) {",
      "\t$0",
      "}"
    ],
    "description": "Declare a function with default parameters in TypeScript"
  },
  "function:param:destructuring object": {
    "prefix": "function_param_destructuring_object",
    "body": [
      "function ${1:functionName}({ ${2:key1}, ${3:key2 }: ${4:Type} }) {",
      "\t$0",
      "}"
    ],
    "description": "Destructuring assignment for object function parameter in TypeScript"
  },
  "function:param:destructuring array": {
    "prefix": "function_param_destructuring_array",
    "body": [
      "function ${1:functionName}([${2:param1}, ${3:param2}]: ${4:Type}[]) {",
      "\t$0",
      "}"
    ],
    "description": "Destructuring assignment for array function parameter in TypeScript"
  },
  "function:generator:declaration": {
    "prefix": "func_generator",
    "body": [
      "function* ${1:functionName}() {",
      "\tyield ${2:value};",
      "}",
      "$0"
    ],
    "description": "Declare a generator function in TypeScript"
  },
  "function:immediately-invoked function expression": {
    "prefix": "func_iife",
    "body": ";(function (${1:arguments}) {\n\t${0}\n})(${2})",
    "description": ";(function (arguments) {\n\n})(value)"
  },
  "function:module default export": {
    "prefix": "function_exp_default",
    "body": "export default ${1:member}",
    "description": "export default member"
  },
  "function:module default export function": {
    "prefix": "function_exp_default_func",
    "body": "export default function ${1:name} (${2:arguments}) {\n\t${0}\n}",
    "description": "export default function nameFunc (arguments) {\n\t${0}\n}"
  },
  "function:async::function immediately-invoked expression": {
    "prefix": "func_iffe_async",
    "body": ";(async (${1:arguments}) => {\n\t${0}\n})(${2})",
    "description": ";(async (arguments) => {\n\n})(value)"
  },
  "function:async:declaration": {
    "prefix": "func_async",
    "body": [
      "async function ${1:functionName}() {",
      "\tconst result = await ${2:promise};",
      "\treturn result;",
      "}",
      "$0"
    ],
    "description": "Declare an async function in TypeScript"
  },
  "function:async:arrow": {
    "prefix": "func_arrow_async",
    "body": "async (${1:arguments}) => {\n\t${0}\n}",
    "description": "async (arguments) => {\n\n}"
  },
  "function:arrow": {
    "prefix": "func_arrow",
    "body": "(${1:arguments}) => ${2:statement}",
    "description": "(arguments) => statement"
  },
  "function:arrow with destructuring": {
    "prefix": "func_arrow_with_param_desctructing",
    "body": "({${1:arguments}}) => ${2:statement}",
    "description": "(\\{arguments\\}) => statement"
  },
  "function:void declaration": {
    "prefix": "func_void",
    "body": ["function ${1:functionName}(): void {", "\t$0", "}"],
    "description": "Declare a void function in TypeScript"
  },
  "if": {
    "prefix": "if_",
    "body": ["if (${1:condition}) {", "\t${0}", "}"],
    "description": ["if (${1:condition}) {", "", "}"]
  },
  "if:else": {
    "prefix": "if_else",
    "body": ["if (${1:condition}) {", "", "} else {", "", "}"],
    "description": ["if (condition) {", "\t$0", "} else {", "\t", "}"]
  },
  "if:elif": {
    "prefix": "if_elif",
    "body": "else if (${1:condition}) {\n\t${0}\n}",
    "description": "else if (condition) {\n\t${0}\n}"
  },
  "else": {
    "prefix": "else_",
    "body": "else {\n\t${0}\n}",
    "description": "else {\n\t${0}\n}"
  },
  "let and if statement": {
    "prefix": "let_if",
    "body": "let ${0} \n if (${2:condition}) {\n\t${1}\n}",
    "description": "let x \n if (condition) {\n\t${1}\n}"
  },
  "switch": {
    "prefix": "switch_",
    "body": [
      "switch (${1:key}) {",
      "\tcase ${2:value}:",
      "\t\t$0",
      "\t\tbreak;",
      "",
      "\tdefault:",
      "\t\tbreak;",
      "}"
    ],
    "description": [
      "switch (key) {",
      "\tcase value:",
      "",
      "\t\tbreak;",
      "",
      "\tdefault:",
      "\t\tbreak;",
      "}"
    ]
  },
  "while": {
    "prefix": "while_",
    "body": ["while (${1:condition}) {", "\t$0", "}"],
    "description": ["while (condition) {", "", "}"]
  },
  "while:iteration from array length": {
    "prefix": "while_iteration_decrementing",
    "body": "let ${1:array}Index = ${1:array}.length\nwhile (${1:array}Index--) {\n\t${0}\n}",
    "description": "let arrayIndex = array.length\nwhile (arrayIndex--) {\n\n}"
  },
  "while:do Statement": {
    "prefix": "do_while",
    "body": ["do {", "\t$0", "} while (${1:condition});"],
    "description": ["do {", "\t$0", "} while (condition);"]
  },
  "try:catch Statement": {
    "prefix": "try_catch",
    "body": ["try {", "\t$0", "} catch (${1:error}) {", "\t", "}"],
    "description": ["try {", "\t$0", "} catch (error) {", "\t", "}"]
  },
  "try:finally": {
    "prefix": "try_finally",
    "body": "try {\n\t${0}\n} finally {\n\t\n}",
    "description": "try {\n\n} finally {\n\n}"
  },
  "try:catch:finally": {
    "prefix": "try_catch_finally",
    "body": "try {\n\t${0}\n} catch (${1:err}) {\n\t\n} finally {\n\t\n}",
    "description": "try {\n\n} catch (err) {\n\n} finally {\n\n}"
  },
  "process.env": {
    "prefix": "process_env",
    "body": "process.env",
    "description": "process.env"
  },
  "before": {
    "prefix": "before_",
    "body": "before(async () => {\n\t${0}\n})",
    "description": "before(async () => {\n\n})"
  },
  "beforeAll": {
    "prefix": "before_all",
    "body": "beforeAll(async () => {\n\t${0}\n})",
    "description": "beforeAll(async () => {\n\n})"
  },
  "beforeEach": {
    "prefix": "before_each",
    "body": "beforeEach(async () => {\n\t${0}\n})",
    "description": "beforeEach(async () => {\n\n})"
  },
  "after": {
    "prefix": "after_",
    "body": "after(() => {\n\t${0}\n})",
    "description": "after(() => {\n\n})"
  },
  "afterEach": {
    "prefix": "after_each",
    "body": "afterEach(() => {\n\t${0}\n})",
    "description": "afterEach(() => {\n\n})"
  },
  "set:immediate": {
    "prefix": "set_immediate",
    "body": "setImmediate(() => {\n\t${0}\n})",
    "description": "setImmediate(() => {\n\n})"
  },
  "set:timeout": {
    "prefix": "set_timeout",
    "body": ["setTimeout(() => {", "\t$0", "}, ${1:timeout});"],
    "description": "Set Timeout Function"
  },
  "set:interval": {
    "prefix": "set_interval",
    "body": ["setInterval(() => {", "\t$0", "}, ${1:interval});"],
    "description": ["setInterval(() => {", "\t", "}, ${1:interval});"]
  },
  "type alias declaration": {
    "prefix": "type_alias",
    "body": ["type ${1:AliasName} = ${2:Type};$0"],
    "description": "Declare a type alias in TypeScript"
  },
  "enum:create:with auto increment": {
    "prefix": "enum_with_auto_inc",
    "body": [
      "enum ${1:EnumName} {",
      "\t${2:Sunday},",
      "\t${3:Monday},",
      "\t${4:Tuesday}",
      "}"
    ],
    "description": "Create an enum with auto-incrementing values"
  },
  "enum:create:with member": {
    "prefix": "enum_with_member_key_value",
    "body": [
      "enum ${1:EnumName} {",
      "\t${2:Up} = ${3:1},",
      "\t${4:Down} = ${5:2}",
      "}"
    ],
    "description": "Declare an enum in TypeScript"
  },
  "enum:create:with string members": {
    "prefix": "enum_with_member_string",
    "body": [
      "enum ${1:EnumName} {",
      "\t${2:Info} = '${3:INFO}',",
      "\t${4:Warn} = '${5:WARN}',",
      "\t${6:Error} = '${7:ERROR}'",
      "}"
    ],
    "description": "Create an enum with string members"
  },
  "region:start": {
    "prefix": "region_start",
    "body": ["//#region $0"],
    "description": "//#region $0"
  },
  "region:end": {
    "prefix": "region_end",
    "body": ["//#endregion"],
    "description": "//#endregion"
  },
  "console:log": {
    "prefix": "log_",
    "body": "console.log(${0})",
    "description": "console.log()"
  },
  "console:dir": {
    "prefix": "log_dir",
    "body": "console.dir('${1}:', ${1})",
    "description": "console.dir('x', y)"
  },
  "console:error": {
    "prefix": "log_err",
    "body": "console.error(${0})",
    "description": "console.error()"
  },
  "console:warn": {
    "prefix": "log_warn_",
    "body": ["console.warn($1);", "$0"],
    "description": "console.warn();"
  },
  "type definition": {
    "prefix": "type_",
    "body": ["type ${1:name} = {", "\t$0", "}"],
    "description": "Type Definition"
  },
  "interface:create": {
    "prefix": "interface_",
    "body": ["interface ${1:name} {", "\t$0", "}"],
    "description": "Interface Definition"
  },
  "interface:export named": {
    "prefix": "interface_export",
    "body": ["export interface ${1:InterfaceName} {", "\t$0", "}"],
    "description": "Export named interface in TypeScript"
  },
  "interface:export default interface declaration": {
    "prefix": "interface_export_default",
    "body": ["export default interface ${1:InterfaceName} {", "\t$0", "}"],
    "description": "Export default interface in TypeScript"
  },
  "triple-slash reference": {
    "prefix": "ref_",
    "body": ["/// <reference path=\"$1\" />", "$0"],
    "description": "Triple-slash reference"
  },
  "class:constructor": {
    "prefix": "class_func_constractor",
    "body": ["/**", " *", " */", "constructor() {", "\tsuper();", "\t$0", "}"],
    "description": "class constructor"
  },
  "class:property": {
    "prefix": "class_prop",
    "body": [
      "",
      "private _${1:value} : ${2:string};",
      "public get ${1:value}() : ${2:string} {",
      "\treturn this._${1:value};",
      "}",
      "public set ${1:value}(v : ${2:string}) {",
      "\tthis._${1:value} = v;",
      "}",
      ""
    ],
    "description": "Define a full property"
  },
  "class:property:private": {
    "prefix": "class_prop_private",
    "body": ["private ${1:propertyName}: ${2:Type};", "$0"],
    "description": "Declare a private property in a class in TypeScript"
  },
  "class:property:protected": {
    "prefix": "class_prop_protected",
    "body": ["protected ${1:propertyName}: ${2:Type};", "$0"],
    "description": "Declare a protected property in a class in TypeScript"
  },
  "class:property:readonly": {
    "prefix": "class_prop_readonly",
    "body": ["readonly ${1:propertyName}: ${2:Type};", "$0"],
    "description": "Declare a readonly property in TypeScript"
  },
  "class:property getter": {
    "prefix": "class_get_public",
    "body": [
      "",
      "public get ${1:value}() : ${2:string} {",
      "\t${3:return $0}",
      "}",
      ""
    ],
    "description": "Property getter"
  },
  "class:property setter": {
    "prefix": "class_set_public",
    "body": [
      "",
      "public set ${1:value}(v : ${2:string}) {",
      "\tthis.$3 = v;",
      "}",
      ""
    ],
    "description": "Property setter"
  },
  "class:getter": {
    "prefix": "class_get",
    "body": "get ${1:property} () {\n\t${0}\n}",
    "description": "get property () {\n\n}"
  },
  "class:setter": {
    "prefix": "class_set",
    "body": "set ${1:property} (${2:value}) {\n\t${0}\n}",
    "description": "set property (value) {\n\n}"
  },
  "class:getter plus with setter": {
    "prefix": "class_set_and_get",
    "body": "get ${1:property} () {\n\t${0}\n}\nset ${1:property} (${2:value}) {\n\t\n}",
    "description": "get property () {\n\n}\nset ${1:property} (value) {\n\t\n}"
  },
  "class": {
    "prefix": "class_",
    "body": [
      "class ${1:name} {",
      "\tconstructor(${2:parameters}) {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Class Definition"
  },
  "class:method": {
    "prefix": "class_method",
    "body": ["/**", " * ${1:name}", " */", "${1:name}() {", "\t$0", "}"],
    "description": "Public Method Definition"
  },
  "class:method private": {
    "prefix": "class_method_private",
    "body": ["private ${1:name}() {", "\t$0", "}"],
    "description": "Private Method Definition"
  },
  "abstract:abstract:method": {
    "prefix": "abstract_func_method",
    "body": ["abstract ${1:methodName}(${2:params}): ${3:ReturnType};", "$0"],
    "description": "Declare an abstract method in TypeScript"
  }
}
